app/globals.css
---
@import "tailwindcss";

@plugin "tailwindcss-animate";

@custom-variant dark (&:is(.dark *));

.pixelated {
  image-rendering: pixelated;
  image-rendering: crisp-edges;
}

@theme inline {
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --font-sans: var(--font-geist-sans);
  --font-mono: var(--font-geist-mono);
  --color-sidebar-ring: var(--sidebar-ring);
  --color-sidebar-border: var(--sidebar-border);
  --color-sidebar-accent-foreground: var(--sidebar-accent-foreground);
  --color-sidebar-accent: var(--sidebar-accent);
  --color-sidebar-primary-foreground: var(--sidebar-primary-foreground);
  --color-sidebar-primary: var(--sidebar-primary);
  --color-sidebar-foreground: var(--sidebar-foreground);
  --color-sidebar: var(--sidebar);
  --color-chart-5: var(--chart-5);
  --color-chart-4: var(--chart-4);
  --color-chart-3: var(--chart-3);
  --color-chart-2: var(--chart-2);
  --color-chart-1: var(--chart-1);
  --color-ring: var(--ring);
  --color-input: var(--input);
  --color-border: var(--border);
  --color-destructive-foreground: var(--destructive-foreground);
  --color-destructive: var(--destructive);
  --color-accent-foreground: var(--accent-foreground);
  --color-accent: var(--accent);
  --color-muted-foreground: var(--muted-foreground);
  --color-muted: var(--muted);
  --color-secondary-foreground: var(--secondary-foreground);
  --color-secondary: var(--secondary);
  --color-primary-foreground: var(--primary-foreground);
  --color-primary: var(--primary);
  --color-popover-foreground: var(--popover-foreground);
  --color-popover: var(--popover);
  --color-card-foreground: var(--card-foreground);
  --color-card: var(--card);
  --radius-sm: calc(var(--radius) - 4px);
  --radius-md: calc(var(--radius) - 2px);
  --radius-lg: var(--radius);
  --radius-xl: calc(var(--radius) + 4px);
}

:root {
  --background: oklch(1 0 0);
  --foreground: oklch(0.129 0.042 264.695);
  --card: oklch(1 0 0);
  --card-foreground: oklch(0.129 0.042 264.695);
  --popover: oklch(1 0 0);
  --popover-foreground: oklch(0.129 0.042 264.695);
  --primary: oklch(0.208 0.042 265.755);
  --primary-foreground: oklch(0.984 0.003 247.858);
  --secondary: oklch(0.968 0.007 247.896);
  --secondary-foreground: oklch(0.208 0.042 265.755);
  --muted: oklch(0.968 0.007 247.896);
  --muted-foreground: oklch(0.554 0.046 257.417);
  --accent: oklch(0.968 0.007 247.896);
  --accent-foreground: oklch(0.208 0.042 265.755);
  --destructive: oklch(0.577 0.245 27.325);
  --destructive-foreground: oklch(0.577 0.245 27.325);
  --border: oklch(0.929 0.013 255.508);
  --input: oklch(0.929 0.013 255.508);
  --ring: oklch(0.704 0.04 256.788);
  --chart-1: oklch(0.646 0.222 41.116);
  --chart-2: oklch(0.6 0.118 184.704);
  --chart-3: oklch(0.398 0.07 227.392);
  --chart-4: oklch(0.828 0.189 84.429);
  --chart-5: oklch(0.769 0.188 70.08);
  --radius: 0.625rem;
  --sidebar: oklch(0.984 0.003 247.858);
  --sidebar-foreground: oklch(0.129 0.042 264.695);
  --sidebar-primary: oklch(0.208 0.042 265.755);
  --sidebar-primary-foreground: oklch(0.984 0.003 247.858);
  --sidebar-accent: oklch(0.968 0.007 247.896);
  --sidebar-accent-foreground: oklch(0.208 0.042 265.755);
  --sidebar-border: oklch(0.929 0.013 255.508);
  --sidebar-ring: oklch(0.704 0.04 256.788);
}

.dark {
  --background: oklch(0.129 0.042 264.695);
  --foreground: oklch(0.984 0.003 247.858);
  --card: oklch(0.129 0.042 264.695);
  --card-foreground: oklch(0.984 0.003 247.858);
  --popover: oklch(0.129 0.042 264.695);
  --popover-foreground: oklch(0.984 0.003 247.858);
  --primary: oklch(0.984 0.003 247.858);
  --primary-foreground: oklch(0.208 0.042 265.755);
  --secondary: oklch(0.279 0.041 260.031);
  --secondary-foreground: oklch(0.984 0.003 247.858);
  --muted: oklch(0.279 0.041 260.031);
  --muted-foreground: oklch(0.704 0.04 256.788);
  --accent: oklch(0.279 0.041 260.031);
  --accent-foreground: oklch(0.984 0.003 247.858);
  --destructive: oklch(0.396 0.141 25.723);
  --destructive-foreground: oklch(0.637 0.237 25.331);
  --border: oklch(0.279 0.041 260.031);
  --input: oklch(0.279 0.041 260.031);
  --ring: oklch(0.446 0.043 257.281);
  --chart-1: oklch(0.488 0.243 264.376);
  --chart-2: oklch(0.696 0.17 162.48);
  --chart-3: oklch(0.769 0.188 70.08);
  --chart-4: oklch(0.627 0.265 303.9);
  --chart-5: oklch(0.645 0.246 16.439);
  --sidebar: oklch(0.208 0.042 265.755);
  --sidebar-foreground: oklch(0.984 0.003 247.858);
  --sidebar-primary: oklch(0.488 0.243 264.376);
  --sidebar-primary-foreground: oklch(0.984 0.003 247.858);
  --sidebar-accent: oklch(0.279 0.041 260.031);
  --sidebar-accent-foreground: oklch(0.984 0.003 247.858);
  --sidebar-border: oklch(0.279 0.041 260.031);
  --sidebar-ring: oklch(0.446 0.043 257.281);
}

@layer base {
  * {
    @apply border-border outline-ring/50;
  }
  body {
    @apply bg-background text-foreground;
  }
}


---
app/layout.tsx
---
import { TooltipProvider } from "@/components/ui/tooltip";
import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import "./globals.css";

const geistSans = Geist({
	variable: "--font-geist-sans",
	subsets: ["latin"],
});

const geistMono = Geist_Mono({
	variable: "--font-geist-mono",
	subsets: ["latin"],
});

export const metadata: Metadata = {
	title: "Pokemon Battling",
	description: "A simple app to battle Pokemon",
	authors: {
		name: "Lakshya Agarwal",
		url: "https://github.com/lakshyaag",
	},
};

export default function RootLayout({
	children,
}: Readonly<{
	children: React.ReactNode;
}>) {
	return (
		<html lang="en">
			<body
				className={`${geistSans.variable} ${geistMono.variable} antialiased`}
			>
				<TooltipProvider>{children}</TooltipProvider>
			</body>
		</html>
	);
}


---
app/page.tsx
---
"use client";

import Link from "next/link";
import { Button } from "@/components/ui/button";
import {
	Card,
	CardHeader,
	CardContent,
	CardFooter,
} from "@/components/ui/card";
import { ArrowRight, Swords, Dices } from "lucide-react";

export default function Home() {
	return (
		<div className="min-h-screen bg-background">
			<div className="container mx-auto px-4 py-16">
				<div className="flex flex-col items-center text-center space-y-6 mb-12">
					<h1 className="text-5xl font-bold tracking-tight">
						Pokemon Battling
					</h1>
					<p className="text-xl text-muted-foreground max-w-2xl">
						Experience thrilling Pokemon battles! Choose your Pokemon and moves,
						or jump straight into a random battle for quick action.
					</p>
				</div>

				<div className="grid grid-cols-1 gap-6 max-w-4xl mx-auto">
					<Card className="flex flex-col">
						<CardHeader>
							<div className="flex items-center gap-2">
								<Dices className="w-6 h-6" />
								<h2 className="text-2xl font-semibold">Quick Random Battle</h2>
							</div>
						</CardHeader>
						<CardContent>
							<p className="text-muted-foreground">
								Jump straight into action with randomly selected Pokemon and
								moves for both you and your opponent.
							</p>
						</CardContent>
						<CardFooter className="mt-auto">
							<Button variant="default" className="w-full" size="lg" asChild>
								<Link
									href="/battle"
									className="flex items-center justify-center gap-2"
								>
									Random Battle <ArrowRight className="w-4 h-4" />
								</Link>
							</Button>
						</CardFooter>
					</Card>
				</div>
			</div>

			<footer className="fixed bottom-0 w-full border-t bg-background/95 backdrop-blur supports-[backdrop-filter]:bg-background/60">
				<div className="container flex h-14 items-center justify-center text-sm">
					<p className="text-muted-foreground">
						Built with @pkmn/ps libraries. Made with ❤️ by{" "}
						<Link
							href="https://github.com/lakshyaag"
							className="underline hover:text-primary"
						>
							Lakshya Agarwal
						</Link>
					</p>
				</div>
			</footer>
		</div>
	);
}


---
app/battle/page.tsx
---
"use client";

import React, { useState, useEffect } from "react";
import BattleView from "@/components/BattleView";
import { Button } from "@/components/ui/button";
import { useRouter } from "next/navigation";
import { battleManager } from "@/services/battle-manager-instance";
import { useSettings } from "@/store/settings";
import { getFormat } from "@/lib/constants";

export default function BattlePage() {
	const { generation } = useSettings();
	const router = useRouter();
	const [battleId, setBattleId] = useState<string | null>(null);

	useEffect(() => {
		// Only create a new battle if we don't have one
		if (!battleId) {
			const id = crypto.randomUUID();
			const format = getFormat(generation);
			const p1Name = "Player 1";
			const p2Name = "Player 2";

			try {
				const battle = battleManager.createBattle(id, {
					format,
					p1Name,
					p2Name,
				});

				// Subscribe to battle end to handle cleanup
				battle.on("battleEnd", () => {
					// Keep the battle around for a minute to allow for viewing results
					setTimeout(() => {
						battleManager.removeBattle(id);
					}, 60000);
				});

				battleManager.startBattle(id);
				setBattleId(id);
			} catch (error) {
				console.error("Error creating battle:", error);
				router.push("/");
			}
		}

		// Cleanup only when explicitly navigating away
		return () => {
			if (battleId) {
				const battle = battleManager.getBattle(battleId);
				if (battle) {
					battleManager.removeBattle(battleId);
				}
			}
		};
	}, [generation, router, battleId]);

	const handleReturnHome = () => {
		if (battleId) {
			battleManager.removeBattle(battleId);
		}
		router.push("/");
	};

	if (!battleId) {
		return <div>Loading Battle...</div>;
	}

	return (
		<div className="container mx-auto py-8">
			<div className="mb-6 flex justify-between items-center">
				<h1 className="text-3xl font-bold">Pokémon Battle</h1>
				<div className="flex gap-4">
					<Button
						variant="outline"
						onClick={handleReturnHome}
					>
						Return to Home
					</Button>
				</div>
			</div>
			<BattleView battleId={battleId} />
		</div>
	);
}


---
app/utils/pokemonUtils.ts
---
import { Generations, type Specie, type GenerationNum } from "@pkmn/data";
import { Dex } from "@pkmn/dex";
import type { PokemonData } from "../components/PokemonSelector";
import { getGraphics } from "@/lib/constants";
import type { Pokemon } from "@pkmn/client";
import { Sprites } from "@pkmn/img";

export type PokemonWithMoves = {
	pokemon: PokemonData;
	moves: string[];
};

/**
 * Generate a random Pokemon for a specific generation
 * @param generation - The generation number
 */
export async function getRandomPokemon(
	generation: GenerationNum,
): Promise<PokemonWithMoves> {
	const gens = new Generations(Dex);
	const gen = gens.get(generation);

	// Get all Pokemon
	const allPokemon = Array.from(gen.species);

	// Select a random Pokemon
	const randomIndex = Math.floor(Math.random() * allPokemon.length);
	const randomPokemon = allPokemon[randomIndex];

	// Get random moves for this Pokemon
	const moves = await getRandomMovesForPokemon(randomPokemon, generation);

	return {
		// @ts-ignore
		pokemon: randomPokemon,
		moves,
	};
}

/**
 * Get random moves for a specific Pokemon in a specific generation
 * @param pokemon - The Pokemon species
 * @param generation - The generation number
 */
export async function getRandomMovesForPokemon(
	pokemon: Specie,
	generation: GenerationNum,
): Promise<string[]> {
	try {
		const gens = new Generations(Dex);
		const gen = gens.get(generation);

		// Wait for the learnsets data to load
		const learnsets = await gen.learnsets.get(pokemon.id);

		if (!learnsets) {
			throw new Error(`No learnset data found for ${pokemon.name}`);
		}

		// Get all moves for this Pokemon
		const availableMoves: string[] = [];

		for (const moveId in learnsets.learnset) {
			const sources = learnsets.learnset[moveId];
			if (sources.some((source) => source.startsWith(generation.toString()))) {
				// Get the actual move object to display proper name
				const move = gen.moves.get(moveId);
				if (move) {
					availableMoves.push(move.name);
				}
			}
		}

		// If we have less than 4 moves, use all of them
		// Otherwise, randomly select 4 moves
		let selectedMoves: string[];
		if (availableMoves.length <= 4) {
			selectedMoves = [...availableMoves];
		} else {
			selectedMoves = [];
			const movesCopy = [...availableMoves];

			while (selectedMoves.length < 4 && movesCopy.length > 0) {
				const randomIndex = Math.floor(Math.random() * movesCopy.length);
				selectedMoves.push(movesCopy[randomIndex]);
				movesCopy.splice(randomIndex, 1);
			}
		}

		return selectedMoves;
	} catch (error) {
		console.error("Error getting moves:", error);
		return [];
	}
}

/**
 * Get the sprite URL for a Pokémon
 */
export function getSprite(
	pokemon: Pokemon,
	player: "p1" | "p2",
	generation: number = 3,
): string {
	// Get species name in the format expected by @pkmn/img
	const species = pokemon.speciesForme.toLowerCase();

	// Get sprite options
	const options = {
		gen: generation,
		shiny: pokemon.shiny,
		gender: pokemon.gender,
		side: player,
		mod: "ani", // Use animated sprites
	};

	// Get sprite URL using static method
	return Sprites.getPokemon(species, options).url;
}

/**
 * Parse HP and status from condition string
 */
export function parseCondition(pokemon?: Pokemon | null) {
	if (!pokemon) return { currentHP: 0, maxHP: 0, status: "" };

	const currentHP = pokemon.hp;
	const maxHP = pokemon.maxhp;
	const status = pokemon.status;

	return { currentHP, maxHP, status };
}

/**
 * Get HP bar color based on percentage
 */
export function getHPColor(percentage: number): string {
	if (percentage > 50) return "bg-green-500";
	if (percentage > 20) return "bg-yellow-500";
	return "bg-red-500";
}


---
app/components/BattleMoveButton.tsx
---
import React from "react";
import { Button } from "./ui/button";
import { Badge } from "./ui/badge";
import { Tooltip, TooltipContent, TooltipTrigger } from "./ui/tooltip";
import { TYPE_COLORS } from "@/lib/constants";

interface BattleMoveButtonProps {
	moveId: string;
	name: string;
	type: string;
	pp: number;
	maxPp: number;
	disabled?: boolean;
	isDisabled?: boolean;
	disabledReason?: string;
	onClick: () => void;
}

/**
 * Button component for displaying and selecting a Pokémon move
 */
export default function BattleMoveButton({
	moveId,
	name,
	type,
	pp,
	maxPp,
	disabled,
	isDisabled,
	disabledReason,
	onClick,
}: BattleMoveButtonProps) {
	const typeClass = TYPE_COLORS[type.toLowerCase() as keyof typeof TYPE_COLORS] || "bg-gray-400 text-white";

	const button = (
		<Button
			variant="outline"
			className={`w-full h-full p-2 flex flex-col items-center justify-between gap-1 ${
				disabled ? "opacity-50" : ""
			}`}
			disabled={disabled}
			onClick={onClick}
		>
			<div className="flex items-center justify-between w-full">
				<span className="font-medium">{name}</span>
				<Badge variant="outline" className={typeClass}>
					{type}
				</Badge>
			</div>
			<div className="text-sm text-gray-500 self-end">
				PP: {pp}/{maxPp}
			</div>
		</Button>
	);

	if (isDisabled && disabledReason) {
		return (
			<Tooltip>
				<TooltipTrigger asChild>{button}</TooltipTrigger>
				<TooltipContent>
					<p>{disabledReason}</p>
				</TooltipContent>
			</Tooltip>
		);
	}

	return button;
}


---
app/components/BattleView.tsx
---
"use client";

import React, { useState, useEffect, useRef } from "react";
import type { BattleState } from "../services/battle-types";
import type { Pokemon, Battle } from "@pkmn/client";
import type { BattleEngine } from "../services/battle-engine";
import { TYPE_COLORS } from "@/lib/constants";
import BattleMoveButton from "./BattleMoveButton";
import { Badge } from "./ui/badge";
import { getStatusClass, getStatusName } from "@/lib/utils";
import { Tooltip, TooltipContent, TooltipTrigger } from "./ui/tooltip";
import { getSprite, parseCondition, getHPColor } from "../utils/pokemonUtils";
import { battleManager } from "@/services/battle-manager-instance";
import { useSettings } from "@/store/settings";

// Add this type to handle battle logs safely
type BattleLog = {
	id: string;
	html: string;
};

interface BattleViewProps {
	battleId: string;
}

/**
 * Component for displaying and interacting with a Pokémon battle
 */
export default function BattleView({ battleId }: BattleViewProps) {
	const battleEngineRef = useRef<BattleEngine | null>(null);
	const { generation } = useSettings();
	const [viewState, setViewState] = useState<BattleState | null>(null);
	const [error, setError] = useState<string | null>(null);
	const [retryCount, setRetryCount] = useState(0);
	const maxRetries = 3;

	// Initialize battle engine and subscribe to updates
	useEffect(() => {
		let retryTimeout: NodeJS.Timeout;
		let mounted = true;

		const initializeBattle = () => {
			const engine = battleManager.getBattle(battleId);

			if (!engine) {
				if (retryCount < maxRetries) {
					// Retry after a short delay
					retryTimeout = setTimeout(() => {
						if (mounted) {
							setRetryCount((prev) => prev + 1);
							initializeBattle();
						}
					}, 1000);
					return;
				}

				setError(`Battle with ID ${battleId} not found or has ended.`);
				setViewState(null);
				return;
			}

			if (!mounted) return;

			battleEngineRef.current = engine;

			// Create a custom Battle type that extends @pkmn/client's Battle
			const battle = engine.getBattle() as Battle & {
				format?: string;
				currentTurn?: number;
				weather?: string;
				winner?: string | null;
				ended?: boolean;
			};

			setViewState({
				battle,
				logs: [...engine.getLogs()], // Create a new array to avoid readonly issues
				p1Request: engine.getP1Request(),
				p2Request: engine.getP2Request(),
			});

			setError(null);
			setRetryCount(0);

			// Subscribe to state updates
			const unsubscribe = engine.on("stateUpdate", (state) => {
				if (mounted) {
					setViewState(state);
				}
			});

			// Handle battle end
			const unsubscribeEnd = engine.on("battleEnd", ({ winner, state }) => {
				if (mounted) {
					console.log(`Battle ${battleId} ended. Winner: ${winner}`);
					setViewState((prev) =>
						prev
							? {
									...prev,
									battle: state as Battle & { winner?: string | null },
								}
							: null,
					);
				}
			});

			return () => {
				unsubscribe();
				unsubscribeEnd();
			};
		};

		const cleanup = initializeBattle();

		return () => {
			mounted = false;
			if (retryTimeout) {
				clearTimeout(retryTimeout);
			}
			if (cleanup) {
				cleanup();
			}
		};
	}, [battleId, retryCount]);

	// Handle player decisions
	const handlePlayerDecision = (player: "p1" | "p2", moveIndex: number) => {
		if (!battleEngineRef.current) return;
		battleEngineRef.current.processPlayerDecision(player, {
			type: "move",
			moveIndex,
		});
	};

	// Render player's Pokémon information
	const renderPokemonInfo = (player: "p1" | "p2") => {
		if (!viewState?.battle) return <div>Loading battle state...</div>;

		const pokemon = viewState.battle[player].active[0];
		const request = player === "p1" ? viewState.p1Request : viewState.p2Request;
		const pokemonFromRequest = request?.side.pokemon[0];

		if (!pokemon) return <div>No active Pokémon</div>;

		const spriteUrl = getSprite(pokemon, player, generation);
		const itemData = pokemonFromRequest?.item
			? battleEngineRef.current?.getItem(pokemonFromRequest.item)
			: null;
		const abilityData = pokemonFromRequest?.baseAbility
			? battleEngineRef.current?.getAbility(pokemonFromRequest.baseAbility)
			: null;

		// Extract HP information
		const { currentHP, maxHP, status } = parseCondition(pokemon);
		const hpPercentage = maxHP > 0 ? (currentHP / maxHP) * 100 : 0;
		const hpColor = getHPColor(hpPercentage);

		return (
			<div className="flex flex-col items-center space-y-4">
				<div className="relative">
					<img
						src={spriteUrl}
						alt={pokemon.name}
						className="w-32 h-32 object-contain pixelated"
					/>
					{status && (
						<Badge className={`absolute bottom-0 right-0 ${getStatusClass(status)}`}>
							{getStatusName(status)}
						</Badge>
					)}
				</div>
				<div className="text-center">
					<h3 className="text-lg font-bold">{pokemon.name}</h3>
					<div className="flex gap-2 justify-center">
						{pokemon.types.map((type) => (
							<Badge key={type} variant="outline">
								{type}
							</Badge>
						))}
					</div>
					<div className="mt-2">
						<div className="h-2 w-full bg-gray-200 rounded-full">
							<div
								className={`h-full ${hpColor} rounded-full`}
								style={{ width: `${hpPercentage}%` }}
							/>
						</div>
						<p className="text-sm mt-1">
							{currentHP} / {maxHP} HP
						</p>
					</div>
					{itemData && (
						<Tooltip>
							<TooltipTrigger asChild>
								<p className="text-sm mt-1 cursor-help">
									<span className="font-semibold">Item:</span> {itemData.name}
								</p>
							</TooltipTrigger>
							<TooltipContent>
								<p>{itemData.desc}</p>
							</TooltipContent>
						</Tooltip>
					)}
					{abilityData && (
						<Tooltip>
							<TooltipTrigger asChild>
								<p className="text-sm cursor-help">
									<span className="font-semibold">Ability:</span>{" "}
									{abilityData.name}
								</p>
							</TooltipTrigger>
							<TooltipContent>
								<p>{abilityData.desc}</p>
							</TooltipContent>
						</Tooltip>
					)}
				</div>
			</div>
		);
	};

	// Render available moves for a player
	const renderMoves = (player: "p1" | "p2") => {
		const request =
			player === "p1" ? viewState?.p1Request : viewState?.p2Request;

		if (!request?.active?.[0]) {
			if (request?.wait) {
				return (
					<div className="text-gray-500 italic">Waiting for opponent...</div>
				);
			}
			return (
				<div className="text-gray-500 italic">
					No move selection needed now.
				</div>
			);
		}

		const moves = request.active[0].moves || [];

		return (
			<div className="grid grid-cols-2 gap-3">
				{moves.map((move, index) => {
					const moveData = battleEngineRef.current?.getMoveData(move.id);
					if (!moveData) return null;

					const isDisabled = move.disabled;
					const isButtonDisabled = !request || isDisabled || move.pp <= 0;

					return (
						<BattleMoveButton
							key={move.id}
							moveId={move.id}
							name={moveData.name}
							type={moveData.type}
							pp={move.pp}
							maxPp={move.maxpp}
							disabled={isButtonDisabled}
							isDisabled={isDisabled}
							disabledReason={
								isDisabled ? "Move disabled by an effect" : undefined
							}
							onClick={() => {
								if (isButtonDisabled) return;
								handlePlayerDecision(player, index + 1);
							}}
						/>
					);
				})}
			</div>
		);
	};

	// Render battle logs
	const renderBattleLogs = () => {
		if (!viewState?.logs) return null;

		return (
			<div className="h-48 overflow-y-auto p-4 bg-gray-50 rounded-lg">
				{viewState.logs.map((log, index) => {
					// Create a unique key using turn number and index
					const key = `${viewState.battle.turn}-${index}`;
					// Sanitize the HTML content (you should add a proper HTML sanitizer library)
					return (
						<div
							key={key}
							className="mb-1 protocol-line"
							// biome-ignore lint/security/noDangerouslySetInnerHtml: <explanation>
							dangerouslySetInnerHTML={{ __html: log }}
						/>
					);
				})}
			</div>
		);
	};

	if (error) {
		return (
			<div className="text-red-500 text-center p-4">
				{error}
				{retryCount < maxRetries && (
					<div className="mt-2">
						Attempting to reconnect... (Attempt {retryCount + 1}/{maxRetries})
					</div>
				)}
			</div>
		);
	}

	if (!viewState?.battle) {
		return <div className="text-center p-4">Loading battle state...</div>;
	}

	const battle = viewState.battle as Battle & {
		format?: string;
		currentTurn?: number;
		weather?: string;
		winner?: string | null;
		ended?: boolean;
	};

	return (
		<div className="flex flex-col w-full max-w-7xl mx-auto p-6 space-y-6">
			{/* Battle Header */}
			<div className="flex items-center justify-center gap-4 p-4 bg-white rounded-xl shadow-sm border border-gray-100">
				<div className="flex items-center gap-2">
					<Badge variant="outline" className="text-lg px-4 py-2">
						Turn: {battle.turn}
					</Badge>
					<Badge variant="secondary" className="text-lg px-4 py-2">
						Current Turn: {battle.currentTurn || battle.turn}
					</Badge>
				</div>
				{battle.weather && battle.weather !== "none" && (
					<Badge variant="outline" className="text-lg px-4 py-2">
						{battle.weather}
					</Badge>
				)}
				{battle.winner && (
					<Badge variant="destructive" className="text-lg px-4 py-2">
						Winner: {battle.winner}
					</Badge>
				)}
				{battle.ended && !battle.winner && (
					<Badge variant="secondary" className="text-lg px-4 py-2">
						Result: Tie
					</Badge>
				)}
			</div>

			{/* Main Battle Grid */}
			<div className="grid grid-cols-3 gap-6">
				{/* Player 1 */}
				<div className="col-span-1">
					{renderPokemonInfo("p1")}
					{renderMoves("p1")}
				</div>

				{/* Battle Log */}
				<div className="col-span-1">{renderBattleLogs()}</div>

				{/* Player 2 */}
				<div className="col-span-1">
					{renderPokemonInfo("p2")}
					{renderMoves("p2")}
				</div>
			</div>
		</div>
	);
}


---
app/services/battle-engine.ts
---
import { Battle } from "@pkmn/client";
import { Generations } from "@pkmn/data";
import {
	type ArgName,
	type ArgType,
	type BattleArgsKWArgType,
	Protocol,
} from "@pkmn/protocol";
import { TeamGenerators } from "@pkmn/randoms";
import {
	BattleStreams,
	Teams as DTeams,
	Dex,
	type ModdedDex,
	PRNG,
} from "@pkmn/sim";
import type { ObjectReadWriteStream } from "@pkmn/streams";
import { LogFormatter } from "@pkmn/view";
import {
	BattleEventEmitter,
	type BattleEventMap,
} from "./battle-event-emitter";
import type {
	BattleState,
	BattleOptions,
	PlayerDecision,
	PlayerRequest,
} from "./battle-types";
import { ManualPlayer } from "./player";

/**
 * Core battle engine that manages the battle state and logic
 */
export class BattleEngine {
	private battle: Battle;
	private streams: ReturnType<typeof BattleStreams.getPlayerStreams>;
	private p1Stream: ObjectReadWriteStream<string>;
	private p2Stream: ObjectReadWriteStream<string>;
	private formatter: LogFormatter;
	private prng: PRNG;
	private dex: ModdedDex;
	private gens: Generations;
	private format: string;
	private eventEmitter: BattleEventEmitter;
	private p1: ManualPlayer;
	private p2: ManualPlayer;
	private logs: string[] = [];
	private p1Request: PlayerRequest | null = null;
	private p2Request: PlayerRequest | null = null;

	/**
	 * Create a battle engine
	 * @param options - The battle options
	 */
	constructor(options: BattleOptions) {
		this.format = options.format || "gen3randombattle";
		this.prng = new PRNG();
		this.dex = Dex.forFormat(this.format);
		// @ts-ignore
		this.gens = new Generations(Dex);
		this.eventEmitter = new BattleEventEmitter();

		// Set up team generators
		DTeams.setGeneratorFactory(TeamGenerators);

		// Create battle streams
		this.streams = BattleStreams.getPlayerStreams(
			new BattleStreams.BattleStream(),
		);
		this.p1Stream = this.streams.p1;
		this.p2Stream = this.streams.p2;

		// Create battle instance
		this.battle = new Battle(this.gens);

		// Create formatter
		this.formatter = new LogFormatter("p1", this.battle);

		// Initialize players
		this.p1 = new ManualPlayer(
			this.p1Stream,
			false,
			options.p1Name,
			(request: PlayerRequest) => this.handlePlayerRequest("p1", request),
		);

		this.p2 = new ManualPlayer(
			this.p2Stream,
			false,
			options.p2Name,
			(request) => this.handlePlayerRequest("p2", request),
		);

		// Set up onBattleUpdate callback if provided
		if (options.onBattleUpdate) {
			this.on("stateUpdate", (state) => {
				if (options.onBattleUpdate) {
					options.onBattleUpdate(state);
				}
			});
		}

		// Start listening to the omniscient stream
		this.startBattleStream();
	}

	/**
	 * Start the battle stream
	 */
	private async startBattleStream(): Promise<void> {
		try {
			for await (const chunk of this.streams.omniscient) {
				for (const line of chunk.split("\n")) {
					const { args, kwArgs } = Protocol.parseBattleLine(line);
					const html = this.formatter.formatHTML(args, kwArgs);
					
					// Update battle state
					this.battle.add(args, kwArgs);

					if (html) {
						this.logs.push(html);
					}
				}

				// Update battle
				this.battle.update();

				// Emit state update event
				this.eventEmitter.emit("stateUpdate", {
					battle: this.battle,
					logs: [...this.logs],
					p1Request: this.p1Request,
					p2Request: this.p2Request
				});
			}
		} catch (error) {
			console.error("Battle stream error:", error);
			this.eventEmitter.emit("battleEnd", { winner: 'error', state: this.battle });
		}
	}

	/**
	 * Handle a player request
	 * @param player - The player ID
	 * @param request - The request
	 */
	private handlePlayerRequest(
		player: "p1" | "p2",
		request: PlayerRequest,
	): void {
		if (player === "p1") {
			this.p1Request = request;
		} else {
			this.p2Request = request;
		}

		this.eventEmitter.emit("playerRequest", { player, request });
		this.eventEmitter.emit("stateUpdate", {
			battle: this.battle,
			logs: [...this.logs],
			p1Request: this.p1Request,
			p2Request: this.p2Request
		});
	}

	/**
	 * Start the battle
	 * @param p1Team - Optional team for player 1
	 * @param p2Team - Optional team for player 2
	 */
	startBattle(p1Team?: string, p2Team?: string): void {
		const spec = { formatid: this.format };

		// Generate random teams if needed
		const createTeam = () => {
			// Use the built-in team generator
			try {
				const generator = TeamGenerators.getTeamGenerator(
					this.format,
					this.prng,
				);
				return DTeams.export(generator.getTeam());
			} catch (error) {
				console.error("Error generating random team:", error);
				return null;
			}
		};

		const p1TeamFinal = p1Team || createTeam();
		const p2TeamFinal = p2Team || createTeam();

		const p1spec = {
			name: this.p1.playerName,
			team: p1TeamFinal ? DTeams.import(p1TeamFinal) : null,
		};
		const p2spec = {
			name: this.p2.playerName,
			team: p2TeamFinal ? DTeams.import(p2TeamFinal) : null,
		};

		// Start the battle
		void this.streams.omniscient.write(`>start ${JSON.stringify(spec)}
>player p1 ${JSON.stringify(p1spec)}
>player p2 ${JSON.stringify(p2spec)}`);

		// Emit battle start event
		this.eventEmitter.emit("battleStart", this.battle);
	}

	/**
	 * Process a player's move decision
	 * @param player - The player ID
	 * @param decision - The player's decision
	 */
	processPlayerDecision(player: "p1" | "p2", decision: PlayerDecision): void {
		// Clear the request as the player has made a choice
		if (player === 'p1') this.p1Request = null;
		else this.p2Request = null;

		if (decision.type === "move") {
			const choice = `move ${decision.moveIndex}`;
			if (player === "p1") {
				void this.p1Stream.write(choice);
			} else {
				void this.p2Stream.write(choice);
			}
			this.eventEmitter.emit("playerMove", { player, moveIndex: decision.moveIndex });
		}

		this.eventEmitter.emit("stateUpdate", {
			battle: this.battle,
			logs: [...this.logs],
			p1Request: this.p1Request,
			p2Request: this.p2Request
		});
	}

	/**
	 * Get data for a move
	 * @param moveId - The move ID
	 * @returns The move data
	 */
	getMoveData(moveId: string) {
		return this.dex.moves.get(moveId);
	}

	/**
	 * Get data for an item
	 * @param itemId - The item ID
	 * @returns The item data
	 */
	getItem(itemId: string) {
		return this.dex.items.get(itemId);
	}

	/**
	 * Get data for an ability
	 * @param abilityId - The ability ID
	 * @returns The ability data
	 */
	getAbility(abilityId: string) {
		return this.dex.abilities.get(abilityId);
	}

	/**
	 * Subscribe to battle events with type safety
	 * @param event - The event name
	 * @param listener - The event listener function
	 * @returns A function to unsubscribe
	 */
	on<K extends keyof BattleEventMap>(
		event: K,
		listener: (data: BattleEventMap[K]) => void,
	): () => void {
		return this.eventEmitter.on(event, listener);
	}

	getBattle(): Readonly<Battle> {
		return this.battle;
	}

	getLogs(): ReadonlyArray<string> {
		return this.logs;
	}

	getP1Request(): Readonly<PlayerRequest> | null {
		return this.p1Request;
	}

	getP2Request(): Readonly<PlayerRequest> | null {
		return this.p2Request;
	}
}


---
app/services/battle-event-emitter.ts
---
import type { Battle } from "@pkmn/client";
import type { BattleState, PlayerRequest } from "./battle-types";

/**
 * Type-safe event map for battle events
 */
export interface BattleEventMap {
    stateUpdate: BattleState;
    battleStart: Battle;
    battleEnd: { winner: string | null; state: Battle };
    playerRequest: { player: "p1" | "p2"; request: PlayerRequest };
    playerMove: { player: "p1" | "p2"; moveIndex: number };
}

/**
 * Simple event emitter for battle events
 */
export class BattleEventEmitter {
    private events: { [K in keyof BattleEventMap]?: Array<(data: BattleEventMap[K]) => void> } = {};

    /**
     * Register an event listener with type safety
     * @param event - The event name
     * @param listener - The event listener function
     * @returns A function to unsubscribe
     */
    on<K extends keyof BattleEventMap>(
        event: K,
        listener: (data: BattleEventMap[K]) => void
    ): () => void {
        if (!this.events[event]) {
            this.events[event] = [];
        }

        this.events[event]?.push(listener);

        return () => {
            if (this.events[event]) {
                this.events[event] = this.events[event]?.filter((l) => l !== listener);
            }
        };
    }

    /**
     * Emit an event with type safety
     * @param event - The event name
     * @param data - The event data
     */
    emit<K extends keyof BattleEventMap>(event: K, data?: BattleEventMap[K]): void {
        if (!this.events[event]) return;

        for (const listener of this.events[event] || []) {
            try {
                listener(data as BattleEventMap[K]);
            } catch (error) {
                console.error(`Error in event listener for ${event}:`, error);
            }
        }
    }

    /**
     * Remove all listeners for an event
     * @param event - The event name (optional, if not provided, removes all listeners)
     */
    removeAllListeners(event?: keyof BattleEventMap): void {
        if (event) {
            this.events[event] = [];
        } else {
            this.events = {};
        }
    }
} 

---
app/services/battle-manager-instance.ts
---
import { BattleManager } from './battle-manager';

/**
 * Singleton instance of BattleManager for centralized battle management
 * This ensures all components use the same instance for managing battles
 */
export const battleManager = new BattleManager(); 

---
app/services/battle-manager.ts
---
import { BattleEngine } from "./battle-engine";
import type { BattleOptions, BattleState, PlayerDecision } from "./battle-types";

/**
 * Class for managing Pokemon battles
 */
export class BattleManager {
    private battles: Map<string, BattleEngine> = new Map();

    /**
     * Create a new battle
     * @param battleId - Unique identifier for the battle
     * @param options - Battle options
     * @returns The created battle engine
     */
    createBattle(battleId: string, options: BattleOptions): BattleEngine {
        // Check if battle with this ID already exists
        if (this.battles.has(battleId)) {
            throw new Error(`Battle with ID ${battleId} already exists`);
        }

        // Create new battle engine
        const battleEngine = new BattleEngine(options);
        
        // Store in battles map
        this.battles.set(battleId, battleEngine);
        
        // Set up cleanup when battle ends
        battleEngine.on("battleEnd", () => {
            // Keep the battle for a while before removing
            setTimeout(() => {
                this.removeBattle(battleId);
            }, 60000); // 1 minute
        });
        
        return battleEngine;
    }

    /**
     * Get a battle by ID
     * @param battleId - The battle ID
     * @returns The battle engine or undefined if not found
     */
    getBattle(battleId: string): BattleEngine | undefined {
        return this.battles.get(battleId);
    }

    /**
     * Remove a battle
     * @param battleId - The battle ID
     * @returns True if battle was removed, false if not found
     */
    removeBattle(battleId: string): boolean {
        return this.battles.delete(battleId);
    }

    /**
     * Get all active battle IDs
     * @returns Array of battle IDs
     */
    getActiveBattleIds(): string[] {
        return Array.from(this.battles.keys());
    }

    /**
     * Start a battle
     * @param battleId - The battle ID
     * @param p1Team - Player 1's team
     * @param p2Team - Player 2's team
     */
    startBattle(battleId: string, p1Team?: string, p2Team?: string): void {
        const battle = this.getBattle(battleId);
        if (!battle) {
            throw new Error(`Battle with ID ${battleId} not found`);
        }
        
        battle.startBattle(p1Team, p2Team);
    }

    /**
     * Make a move for a player
     * @param battleId - The battle ID
     * @param player - The player ("p1" or "p2")
     * @param decision - The player's decision
     */
    makePlayerMove(
        battleId: string, 
        player: "p1" | "p2", 
        decision: PlayerDecision
    ): void {
        const battle = this.getBattle(battleId);
        if (!battle) {
            throw new Error(`Battle with ID ${battleId} not found`);
        }
        
        battle.processPlayerDecision(player, decision);
    }
} 

---
app/services/battle-types.ts
---
import type { Pokemon, Battle } from "@pkmn/client";

/**
 * Interface for move data
 */
export interface MoveData {
    id: string;
    move: string;
    pp: number;
    maxpp: number;
    disabled?: boolean;
}

/**
 * Interface for battle options
 */
export interface BattleOptions {
    format: string;
    p1Name: string;
    p2Name: string;
    p1Team?: string;
    p2Team?: string;
    onBattleUpdate?: (state: BattleState) => void;
}

/**
 * Interface for player state in battle
 */
export interface PlayerState {
    name?: string;
    active: Pokemon | null;
    team: Pokemon[];
    request: PlayerRequest | null;
    selectedMove: PlayerDecision | null;
}

/**
 * Interface for battle state
 */
export interface BattleState {
    battle: Battle;
    logs: string[];
    p1Request: PlayerRequest | null;
    p2Request: PlayerRequest | null;
}

/**
 * Interface for player request from the battle stream
 */
export interface PlayerRequest {
    active?: {
        moves: Array<{
            id: string;
            pp: number;
            maxpp: number;
            target: string;
            disabled?: boolean;
        }>;
    }[];
    side: {
        name: string;
        id: string;
        pokemon: Array<{
            ident: string;
            details: string;
            condition: string;
            active: boolean;
            stats: {
                atk: number;
                def: number;
                spa: number;
                spd: number;
                spe: number;
            };
            moves: string[];
            baseAbility: string;
            item: string;
            pokeball: string;
            ability: string;
        }>;
    };
    rqid: number;
    wait?: boolean;
}

/**
 * Interface for player decisions
 */
export interface PlayerDecision {
    type: "move";
    moveIndex: number;
}

/**
 * Interface for player switch decision
 */
export interface SwitchDecision {
    type: "switch";
    pokemonIndex: number;
}

/**
 * Union type for player decisions
 */
export type PlayerDecision = MoveDecision | SwitchDecision;

/**
 * Interface for battle turn result
 */
export interface TurnResult {
    turn: number;
    state: Readonly<BattleState>;
}

/**
 * Interface for battle end result
 */
export interface BattleEndResult {
    winner: string;
    state: Readonly<BattleState>;
}

/**
 * Interface for player move event
 */
export interface PlayerMoveEvent {
    player: "p1" | "p2";
    moveIndex: number;
}

/**
 * Interface for player request event
 */
export interface PlayerRequestEvent {
    player: "p1" | "p2";
    request: PlayerRequest;
} 

---
app/services/player.ts
---
import type { ObjectReadWriteStream } from "@pkmn/streams";
import type { PlayerRequest } from "./battle-types";
/**
 * Class representing a manual player in a Pokémon battle
 */
export class ManualPlayer {
    stream: ObjectReadWriteStream<string>;
    log: string[] = [];
    debug: boolean;
    playerName: string;
    onRequestReceived: (request: PlayerRequest) => void;

    /**
     * Create a manual player
     * @param playerStream - The player's stream
     * @param debug - Whether to enable debug logging
     * @param playerName - The player's name
     * @param onRequestReceived - Callback for when a request is received
     */
    constructor(
        playerStream: ObjectReadWriteStream<string>,
        debug = false,
        playerName = "Unknown",
        onRequestReceived: (request: PlayerRequest) => void = () => { },
    ) {
        this.stream = playerStream;
        this.debug = debug;
        this.playerName = playerName;
        this.onRequestReceived = onRequestReceived;

        void this.startListening();
    }

    /**
     * Start listening to the stream
     */
    async startListening(): Promise<void> {
        try {
            for await (const chunk of this.stream) {
                this.receive(chunk);
            }
        } catch (error) {
            console.error(`${this.playerName} stream error:`, error);
        }
    }

    /**
     * Receive a chunk of data from the stream
     * @param chunk - The data chunk
     */
    receive(chunk: string): void {
        if (this.debug) console.log(`${this.playerName} received:`, chunk);

        for (const line of chunk.split("\n")) {
            this.receiveLine(line);
        }
    }

    /**
     * Receive a line of data
     * @param line - The data line
     */
    receiveLine(line: string): void {
        if (this.debug) console.log(`${this.playerName} line:`, line);
        if (!line.startsWith("|")) return;

        const [cmd, rest] =
            line.slice(1).split("|", 1)[0] === ""
                ? ["", line.slice(1)]
                : [
                    line.slice(1).split("|", 1)[0],
                    line.slice(line.indexOf("|", 1) + 1),
                ];

        if (cmd === "request") {
            try {
                const request = JSON.parse(rest);
                this.receiveRequest(request);
            } catch (e) {
                console.error(`${this.playerName} error parsing request:`, e, rest);
            }
            return;
        }

        if (cmd === "error") {
            this.receiveError(new Error(rest));
            return;
        }

        this.log.push(line);
    }

    /**
     * Handle an error
     * @param error - The error
     */
    receiveError(error: Error): void {
        console.error(`${this.playerName} battle error:`, error);

        // If we made an unavailable choice we will receive a followup request to
        // allow us the opportunity to correct our decision.
        if (error.message.startsWith("[Unavailable choice]")) return;
    }

    /**
     * Handle a request
     * @param request - The request
     */
    receiveRequest(request: PlayerRequest): void {
        if (this.debug) console.log(`${this.playerName} received request:`, request);
        this.onRequestReceived(request);
    }

    /**
     * Make a move
     * @param moveIndex - The move index (1-based)
     */
    makeMove(moveIndex: number): void {
        this.makeChoice(`move ${moveIndex}`);
    }

    /**
     * Make a choice
     * @param choice - The choice string
     */
    makeChoice(choice: string): void {
        console.log(`${this.playerName} making choice: ${choice}`);
        try {
            void this.stream.write(choice);
        } catch (error) {
            console.error(`${this.playerName} error making choice:`, error);
        }
    }
}

---
app/store/settings.ts
---
import { create } from "zustand";
import { persist } from "zustand/middleware";
import type { GenerationNum } from "@pkmn/types";

interface SettingsState {
    generation: GenerationNum;
    setGeneration: (generation: GenerationNum) => void;
}

export const useSettings = create<SettingsState>()(
    persist(
        (set) => ({
            generation: 3,
            setGeneration: (generation) => set({ generation }),
        }),
        {
            name: "pokemon-battle-settings",
        }
    )
); 

---
lib/constants.ts
---
import type { GraphicsGen } from "@pkmn/img";
import { PRNG } from "@pkmn/sim";
import type { GenerationNum, TypeName } from "@pkmn/types";

const SPRITES: { [gen in GenerationNum]: GraphicsGen[] } = {
    1: ['gen1rg', 'gen1rb', 'gen1'],
    2: ['gen2g', 'gen2s', 'gen2'],
    3: ['gen3rs', 'gen3frlg', 'gen3', 'gen3-2'],
    4: ['gen4dp', 'gen4dp-2', 'gen4'],
    5: ['gen5', 'gen5ani'],
    6: ['ani'],
    7: ['ani'],
    8: ['ani'],
    9: ['ani'],
};

const prng = new PRNG();
export const getFormat = (generation: GenerationNum) => `gen${generation}randombattle`;
export const getGraphics = (generation: GenerationNum) => prng.sample(SPRITES[generation]);

// Type color mapping
export const TYPE_COLORS: Partial<Record<TypeName, string>> = {
    Normal: "bg-gray-400",
    Fire: "bg-red-500",
    Water: "bg-blue-500",
    Electric: "bg-yellow-400",
    Grass: "bg-green-500",
    Ice: "bg-blue-200",
    Fighting: "bg-red-700",
    Poison: "bg-purple-500",
    Ground: "bg-yellow-600",
    Flying: "bg-indigo-400",
    Psychic: "bg-pink-500",
    Bug: "bg-lime-500",
    Rock: "bg-yellow-800",
    Ghost: "bg-purple-700",
    Dragon: "bg-indigo-600",
    Dark: "bg-gray-800",
    Steel: "bg-gray-500",
    Fairy: "bg-pink-300",
};

---
lib/utils.ts
---
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}


export const getStatusClass = (status: string): string => {
  // Get status class for styling
  switch (status.toLowerCase()) {
    case "par":
      return "bg-yellow-400 text-yellow-900";
    case "psn":
    case "tox":
      return "bg-purple-600 text-white";
    case "brn":
      return "bg-orange-500 text-white";
    case "slp":
      return "bg-gray-400 text-gray-900";
    case "frz":
      return "bg-blue-300 text-blue-900";
    default:
      return "bg-gray-600 text-white";
  }
};

// Get status display name
export const getStatusName = (status: string): string => {
  switch (status.toLowerCase()) {
    case "par":
      return "Paralyzed";
    case "psn":
      return "Poisoned";
    case "tox":
      return "Badly Poisoned";
    case "brn":
      return "Burned";
    case "slp":
      return "Asleep";
    case "frz":
      return "Frozen";
    default:
      return status;
  }
};


---
