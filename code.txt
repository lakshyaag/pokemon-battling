app/globals.css
---
@import "tailwindcss";

@plugin "tailwindcss-animate";

@custom-variant dark (&:is(.dark *));

@theme inline {
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --font-sans: var(--font-geist-sans);
  --font-mono: var(--font-geist-mono);
  --color-sidebar-ring: var(--sidebar-ring);
  --color-sidebar-border: var(--sidebar-border);
  --color-sidebar-accent-foreground: var(--sidebar-accent-foreground);
  --color-sidebar-accent: var(--sidebar-accent);
  --color-sidebar-primary-foreground: var(--sidebar-primary-foreground);
  --color-sidebar-primary: var(--sidebar-primary);
  --color-sidebar-foreground: var(--sidebar-foreground);
  --color-sidebar: var(--sidebar);
  --color-chart-5: var(--chart-5);
  --color-chart-4: var(--chart-4);
  --color-chart-3: var(--chart-3);
  --color-chart-2: var(--chart-2);
  --color-chart-1: var(--chart-1);
  --color-ring: var(--ring);
  --color-input: var(--input);
  --color-border: var(--border);
  --color-destructive-foreground: var(--destructive-foreground);
  --color-destructive: var(--destructive);
  --color-accent-foreground: var(--accent-foreground);
  --color-accent: var(--accent);
  --color-muted-foreground: var(--muted-foreground);
  --color-muted: var(--muted);
  --color-secondary-foreground: var(--secondary-foreground);
  --color-secondary: var(--secondary);
  --color-primary-foreground: var(--primary-foreground);
  --color-primary: var(--primary);
  --color-popover-foreground: var(--popover-foreground);
  --color-popover: var(--popover);
  --color-card-foreground: var(--card-foreground);
  --color-card: var(--card);
  --radius-sm: calc(var(--radius) - 4px);
  --radius-md: calc(var(--radius) - 2px);
  --radius-lg: var(--radius);
  --radius-xl: calc(var(--radius) + 4px);
}

:root {
  --background: oklch(1 0 0);
  --foreground: oklch(0.129 0.042 264.695);
  --card: oklch(1 0 0);
  --card-foreground: oklch(0.129 0.042 264.695);
  --popover: oklch(1 0 0);
  --popover-foreground: oklch(0.129 0.042 264.695);
  --primary: oklch(0.208 0.042 265.755);
  --primary-foreground: oklch(0.984 0.003 247.858);
  --secondary: oklch(0.968 0.007 247.896);
  --secondary-foreground: oklch(0.208 0.042 265.755);
  --muted: oklch(0.968 0.007 247.896);
  --muted-foreground: oklch(0.554 0.046 257.417);
  --accent: oklch(0.968 0.007 247.896);
  --accent-foreground: oklch(0.208 0.042 265.755);
  --destructive: oklch(0.577 0.245 27.325);
  --destructive-foreground: oklch(0.577 0.245 27.325);
  --border: oklch(0.929 0.013 255.508);
  --input: oklch(0.929 0.013 255.508);
  --ring: oklch(0.704 0.04 256.788);
  --chart-1: oklch(0.646 0.222 41.116);
  --chart-2: oklch(0.6 0.118 184.704);
  --chart-3: oklch(0.398 0.07 227.392);
  --chart-4: oklch(0.828 0.189 84.429);
  --chart-5: oklch(0.769 0.188 70.08);
  --radius: 0.625rem;
  --sidebar: oklch(0.984 0.003 247.858);
  --sidebar-foreground: oklch(0.129 0.042 264.695);
  --sidebar-primary: oklch(0.208 0.042 265.755);
  --sidebar-primary-foreground: oklch(0.984 0.003 247.858);
  --sidebar-accent: oklch(0.968 0.007 247.896);
  --sidebar-accent-foreground: oklch(0.208 0.042 265.755);
  --sidebar-border: oklch(0.929 0.013 255.508);
  --sidebar-ring: oklch(0.704 0.04 256.788);
}

.dark {
  --background: oklch(0.129 0.042 264.695);
  --foreground: oklch(0.984 0.003 247.858);
  --card: oklch(0.129 0.042 264.695);
  --card-foreground: oklch(0.984 0.003 247.858);
  --popover: oklch(0.129 0.042 264.695);
  --popover-foreground: oklch(0.984 0.003 247.858);
  --primary: oklch(0.984 0.003 247.858);
  --primary-foreground: oklch(0.208 0.042 265.755);
  --secondary: oklch(0.279 0.041 260.031);
  --secondary-foreground: oklch(0.984 0.003 247.858);
  --muted: oklch(0.279 0.041 260.031);
  --muted-foreground: oklch(0.704 0.04 256.788);
  --accent: oklch(0.279 0.041 260.031);
  --accent-foreground: oklch(0.984 0.003 247.858);
  --destructive: oklch(0.396 0.141 25.723);
  --destructive-foreground: oklch(0.637 0.237 25.331);
  --border: oklch(0.279 0.041 260.031);
  --input: oklch(0.279 0.041 260.031);
  --ring: oklch(0.446 0.043 257.281);
  --chart-1: oklch(0.488 0.243 264.376);
  --chart-2: oklch(0.696 0.17 162.48);
  --chart-3: oklch(0.769 0.188 70.08);
  --chart-4: oklch(0.627 0.265 303.9);
  --chart-5: oklch(0.645 0.246 16.439);
  --sidebar: oklch(0.208 0.042 265.755);
  --sidebar-foreground: oklch(0.984 0.003 247.858);
  --sidebar-primary: oklch(0.488 0.243 264.376);
  --sidebar-primary-foreground: oklch(0.984 0.003 247.858);
  --sidebar-accent: oklch(0.279 0.041 260.031);
  --sidebar-accent-foreground: oklch(0.984 0.003 247.858);
  --sidebar-border: oklch(0.279 0.041 260.031);
  --sidebar-ring: oklch(0.446 0.043 257.281);
}

@layer base {
  * {
    @apply border-border outline-ring/50;
  }
  body {
    @apply bg-background text-foreground;
  }
}


---
app/layout.tsx
---
import { TooltipProvider } from "@/components/ui/tooltip";
import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import "./globals.css";

const geistSans = Geist({
	variable: "--font-geist-sans",
	subsets: ["latin"],
});

const geistMono = Geist_Mono({
	variable: "--font-geist-mono",
	subsets: ["latin"],
});

export const metadata: Metadata = {
	title: "Pokemon Battling",
	description: "A simple app to battle Pokemon",
	authors: {
		name: "Lakshya Agarwal",
		url: "https://github.com/lakshyaag",
	},
};

export default function RootLayout({
	children,
}: Readonly<{
	children: React.ReactNode;
}>) {
	return (
		<html lang="en">
			<body
				className={`${geistSans.variable} ${geistMono.variable} antialiased`}
			>
				<TooltipProvider>{children}</TooltipProvider>
			</body>
		</html>
	);
}


---
app/page.tsx
---
"use client";

import Link from "next/link";
import { Button } from "@/components/ui/button";
import {
	Card,
	CardHeader,
	CardContent,
	CardFooter,
} from "@/components/ui/card";
import { ArrowRight, Swords, Dices } from "lucide-react";
import { GenerationSelector } from "@/components/GenerationSelector";

export default function Home() {
	return (
		<div className="min-h-screen bg-background">
			<div className="container mx-auto px-4 py-16">
				<div className="flex flex-col items-center text-center space-y-6 mb-12">
					<h1 className="text-5xl font-bold tracking-tight">
						Pokemon Battling
					</h1>
					<p className="text-xl text-muted-foreground max-w-2xl">
						Experience thrilling Pokemon battles! Choose your Pokemon and moves,
						or jump straight into a random battle for quick action.
					</p>
					<div className="flex items-center gap-4">
						<p className="text-muted-foreground">Select Pokemon Generation:</p>
						<GenerationSelector />
					</div>
				</div>

				<div className="grid grid-cols-1 md:grid-cols-2 gap-6 max-w-4xl mx-auto">
					<Card className="flex flex-col">
						<CardHeader>
							<div className="flex items-center gap-2">
								<Dices className="w-6 h-6" />
								<h2 className="text-2xl font-semibold">Quick Random Battle</h2>
							</div>
						</CardHeader>
						<CardContent>
							<p className="text-muted-foreground">
								Jump straight into action with randomly selected Pokemon and
								moves for both you and your opponent.
							</p>
						</CardContent>
						<CardFooter className="mt-auto">
							<Button variant="default" className="w-full" size="lg" asChild>
								<Link
									href="/battle"
									className="flex items-center justify-center gap-2"
								>
									Random Battle <ArrowRight className="w-4 h-4" />
								</Link>
							</Button>
						</CardFooter>
					</Card>

					<Card className="flex flex-col">
						<CardHeader>
							<div className="flex items-center gap-2">
								<Swords className="w-6 h-6" />
								<h2 className="text-2xl font-semibold">Choose & Battle</h2>
							</div>
						</CardHeader>
						<CardContent>
							<p className="text-muted-foreground">
								Select your favorite Pokemon from the Pokedex, get assigned
								random moves, and battle against a computer opponent.
							</p>
						</CardContent>
						<CardFooter className="mt-auto">
							<Button className="w-full" size="lg" variant="outline" asChild>
								<Link
									href="/pkmn-select"
									className="flex items-center justify-center gap-2"
								>
									Start Battle <ArrowRight className="w-4 h-4" />
								</Link>
							</Button>
						</CardFooter>
					</Card>
				</div>

				<Card className="mt-12 max-w-4xl mx-auto">
					<CardHeader>
						<h2 className="text-2xl font-semibold">How It Works</h2>
					</CardHeader>
					<CardContent>
						<ol className="list-decimal pl-5 space-y-3 text-lg">
							<li>
								Select your Pokemon from the Pokedex (or get a random one)
							</li>
							<li>Get assigned 4 random moves from that Pokemon's learnset</li>
							<li>
								<b>FIGHT!</b>
							</li>
						</ol>
					</CardContent>
				</Card>
			</div>

			<footer className="fixed bottom-0 w-full border-t bg-background/95 backdrop-blur supports-[backdrop-filter]:bg-background/60">
				<div className="container flex h-14 items-center justify-center text-sm">
					<p className="text-muted-foreground">
						Built with @pkmn/ps libraries. Made with ❤️ by{" "}
						<Link
							href="https://github.com/lakshyaag"
							className="underline hover:text-primary"
						>
							Lakshya Agarwal
						</Link>
					</p>
				</div>
			</footer>
		</div>
	);
}


---
app/battle/page.tsx
---
"use client";

import React from "react";
import BattleComponent from "@/components/BattleView";
import { useBattleStore } from "@/store/battle-store";
import { Button } from "@/components/ui/button";
import { useRouter } from "next/navigation";

export default function BattlePage() {
	const { p1Team, p2Team } = useBattleStore();
	const router = useRouter();

	// No redirect - we'll use random teams if none are provided

	return (
		<div className="container mx-auto py-8">
			<div className="mb-6 flex justify-between items-center">
				<h1 className="text-3xl font-bold">Pokémon Battle</h1>
				<div className="flex gap-4">
					<Button
						variant="outline"
						onClick={() => router.push("/")}
					>
						Return to Home
					</Button>
				</div>
			</div>
			<BattleComponent 
				format="gen3randombattle"
				p1Name="Player 1"
				p2Name="Player 2"
				p1Team={p1Team || undefined}
				p2Team={p2Team || undefined}
			/>
		</div>
	);
}


---
app/pkmn-select/page.tsx
---
"use client";
import PokemonSelector from "../components/PokemonSelector";
import {
	Card,
	CardContent,
	CardDescription,
	CardHeader,
	CardTitle,
} from "@/components/ui/card";
import { useSettings } from "../store/settings";
import { getFormat } from "@/lib/constants";

/**
 * Page for selecting a Pokemon to battle with
 */
export default function SelectPokemonPage() {
	const { generation } = useSettings();
	return (
		<main className="container mx-auto py-8 px-4">
			<Card>
				<CardHeader>
					<CardTitle className="text-3xl">Select Your Pokemon</CardTitle>
					<CardDescription>
						Choose one Pokemon to use in your battle. You'll get 4 random moves
						from its moveset. The format is <pre>{getFormat(generation)}</pre>
					</CardDescription>
				</CardHeader>
				<CardContent>
					<PokemonSelector />
				</CardContent>
			</Card>
		</main>
	);
}


---
app/utils/pokemonUtils.ts
---
import { Generations, type Specie } from "@pkmn/data";
import { Dex } from "@pkmn/dex";
import type { PokemonData } from "../components/PokemonSelector";
import { useSettings } from "@/app/store/settings";
import { getGraphics } from "@/lib/constants";
import type { Pokemon } from "@pkmn/client";
import { Sprites } from "@pkmn/img";

export type PokemonWithMoves = {
	pokemon: PokemonData;
	moves: string[];
};

/**
 * Generate a random Pokemon
 */
export async function getRandomPokemon(): Promise<PokemonWithMoves> {
	const { generation } = useSettings.getState();
	const gens = new Generations(Dex);
	const gen = gens.get(generation);

	// Get all Pokemon
	const allPokemon = Array.from(gen.species);

	// Select a random Pokemon
	const randomIndex = Math.floor(Math.random() * allPokemon.length);
	const randomPokemon = allPokemon[randomIndex];

	// Get random moves for this Pokemon
	const moves = await getRandomMovesForPokemon(randomPokemon);

	return {
		// @ts-ignore
		pokemon: randomPokemon,
		moves,
	};
}

/**
 * Get random moves for a specific Pokemon
 */
export async function getRandomMovesForPokemon(
	pokemon: Specie,
): Promise<string[]> {
	try {
		const { generation } = useSettings.getState();
		const gens = new Generations(Dex);
		const gen = gens.get(generation);

		// Wait for the learnsets data to load
		const learnsets = await gen.learnsets.get(pokemon.id);

		if (!learnsets) {
			throw new Error(`No learnset data found for ${pokemon.name}`);
		}

		// Get all moves for this Pokemon
		const availableMoves: string[] = [];

		for (const moveId in learnsets.learnset) {
			const sources = learnsets.learnset[moveId];
			if (sources.some((source) => source.startsWith(generation.toString()))) {
				// Get the actual move object to display proper name
				const move = gen.moves.get(moveId);
				if (move) {
					availableMoves.push(move.name);
				}
			}
		}

		// If we have less than 4 moves, use all of them
		// Otherwise, randomly select 4 moves
		let selectedMoves: string[];
		if (availableMoves.length <= 4) {
			selectedMoves = [...availableMoves];
		} else {
			selectedMoves = [];
			const movesCopy = [...availableMoves];

			while (selectedMoves.length < 4 && movesCopy.length > 0) {
				const randomIndex = Math.floor(Math.random() * movesCopy.length);
				selectedMoves.push(movesCopy[randomIndex]);
				movesCopy.splice(randomIndex, 1);
			}
		}

		return selectedMoves;
	} catch (error) {
		console.error("Error getting moves:", error);
		return [];
	}
}

export const getSprite = (pokemon: Pokemon, player: "p1" | "p2") => {
	const { generation } = useSettings.getState();
	return Sprites.getPokemon(pokemon.speciesForme, {
		side: player,
		gender: pokemon.gender || undefined,
		gen: getGraphics(generation),
		shiny: pokemon.shiny,
	});
}

---
app/components/BackgroundMusic.tsx
---
import { useEffect, useState } from "react";
import { Button } from "@/components/ui/button";
import { Volume2, VolumeX } from "lucide-react";

export default function BackgroundMusic() {
	const [audio] = useState(
		typeof Audio !== "undefined" ? new Audio("/audio/battle-theme.mp3") : null,
	);
	const [isPlaying, setIsPlaying] = useState(false);

	useEffect(() => {
		if (audio) {
			audio.loop = true;
			audio.volume = 0.4;

			const playAudio = async () => {
				try {
					await audio.play();
					setIsPlaying(true);
				} catch (err) {
					console.error("Failed to play audio:", err);
				}
			};
		}

		return () => {
			if (audio) {
				audio.pause();
				audio.currentTime = 0;
			}
		};
	}, [audio]);

	const togglePlay = async () => {
		if (!audio) return;

		if (isPlaying) {
			audio.pause();
		} else {
			try {
				await audio.play();
			} catch (err) {
				console.error("Failed to play audio:", err);
			}
		}
		setIsPlaying(!isPlaying);
	};

	return (
		<Button
			variant="ghost"
			size="icon"
			className="fixed top-4 right-4 z-50"
			onClick={togglePlay}
			title={isPlaying ? "Mute music" : "Play music"}
		>
			{isPlaying ? (
				<Volume2 className="h-6 w-6" />
			) : (
				<VolumeX className="h-6 w-6" />
			)}
		</Button>
	);
}


---
app/components/BattleMoveButton.tsx
---
import type { Move } from "@pkmn/data";
import React from "react";
import type { MoveData } from "../services/player";
import {
	Tooltip,
	TooltipContent,
	TooltipTrigger,
} from "@/components/ui/tooltip";
import { Badge } from "@/components/ui/badge";
import { TYPE_COLORS } from "@/lib/constants";

type BattleMoveButtonProps = {
	moveDetails: MoveData;
	moveData: Move;
	isSelected: boolean;
	onClick: () => void;
	disabled?: boolean;
};

export default function BattleMoveButton({
	moveDetails,
	moveData,
	isSelected,
	onClick,
	disabled = false,
}: BattleMoveButtonProps) {
	return (
		<Tooltip>
			<TooltipTrigger asChild>
				<button
					type="button"
					onClick={onClick}
					disabled={disabled}
					className={`
							w-full py-2 px-3 rounded text-sm capitalize border
							${
								isSelected
									? "bg-green-500 text-white border-green-600"
									: "bg-white hover:bg-gray-100 border-gray-300"
							}
							${disabled ? "opacity-50 cursor-not-allowed" : "cursor-pointer"}
						`}
				>
					{moveData.name.replace(/-/g, " ")}
				</button>
			</TooltipTrigger>
			<TooltipContent className="p-3 max-w-xs">
				<div className="space-y-2">
					<div className="flex items-center justify-between">
						<span className="font-semibold">{moveData.name}</span>
						<Badge className={`${TYPE_COLORS[moveData.type]} text-white`}>
							{moveData.type}
						</Badge>
					</div>
					<div className="grid grid-cols-3 gap-2 text-xs">
						<div>
							<span className="font-medium">Power:</span>{" "}
							{moveData.basePower || "-"}
						</div>
						<div>
							<span className="font-medium">Acc:</span>{" "}
							{moveData.accuracy === true ? "-" : moveData.accuracy}
						</div>
						<div>
							<span className="font-medium">PP:</span> {moveDetails.pp} /{" "}
							{moveDetails.maxpp}
						</div>
					</div>
					<div className="text-xs text-gray-600">
						{moveData.shortDesc || moveData.desc || "No description available."}
					</div>
				</div>
			</TooltipContent>
		</Tooltip>
	);
}


---
app/components/BattleView.tsx
---
"use client";

import React, { useState, useEffect, useRef } from "react";
import type { BattleState } from "../services/battle-types";
import type { Pokemon } from "@pkmn/client";
import { BattleEngine } from "../services/battle-engine";
import { TYPE_COLORS } from "@/lib/constants";
import BattleMoveButton from "./BattleMoveButton";
import { Badge } from "./ui/badge";
import { getStatusClass, getStatusName } from "@/lib/utils";
import { Tooltip, TooltipContent, TooltipTrigger } from "./ui/tooltip";
import { getSprite } from "../utils/pokemonUtils";

interface BattleComponentProps {
	format: string;
	p1Name?: string;
	p2Name?: string;
	p1Team?: string;
	p2Team?: string;
}

/**
 * Component for displaying and interacting with a Pokémon battle
 */
export default function BattleComponent({
	format,
	p1Name = "Player 1",
	p2Name = "Player 2",
	p1Team,
	p2Team,
}: BattleComponentProps) {
	const battleEngineRef = useRef<BattleEngine | null>(null);
	const [battleState, setBattleState] = useState<BattleState>({
		turn: 0,
		p1: {
			name: p1Name,
			active: null,
			team: [],
			request: null,
			selectedMove: null,
		},
		p2: {
			name: p2Name,
			active: null,
			team: [],
			request: null,
			selectedMove: null,
		},
		weather: "none",
		status: "Initializing battle...",
		logs: [],
		isComplete: false,
		winner: null,
	});
	const [isInitialized, setIsInitialized] = useState(false);

	// Initialize battle engine
	useEffect(() => {
		if (!isInitialized) {
			const battleEngine = new BattleEngine({
				format,
				p1Name,
				p2Name,
				p1Team,
				p2Team,
				onBattleUpdate: (state: BattleState) => {
					setBattleState(state);
				},
			});

			// Subscribe to state updates
			battleEngine.on("stateUpdate", (state) => {
				setBattleState(state);
			});

			battleEngineRef.current = battleEngine;
			setIsInitialized(true);

			// Start the battle
			battleEngine.startBattle(p1Team, p2Team);

			// Cleanup function
			return () => {
				// Clean up any subscriptions or resources
			};
		}
	}, [format, p1Name, p2Name, p1Team, p2Team, isInitialized]);

	// Handle move selection for player 1
	const handleP1MoveSelect = (moveIndex: number) => {
		if (!battleEngineRef.current) return;

		battleEngineRef.current.processPlayerDecision("p1", {
			type: "move",
			moveIndex,
		});
	};

	// Handle move selection for player 2
	const handleP2MoveSelect = (moveIndex: number) => {
		if (!battleEngineRef.current) return;

		battleEngineRef.current.processPlayerDecision("p2", {
			type: "move",
			moveIndex,
		});
	};

	// Parse HP and status from condition string
	const parseCondition = (pokemon?: Pokemon) => {
		if (!pokemon) return { currentHP: 0, maxHP: 0, status: "" };

		const currentHP = pokemon.hp;
		const maxHP = pokemon.maxhp;
		const status = pokemon.status;

		return { currentHP, maxHP, status };
	};

	// Render player's Pokémon information
	const renderPokemonInfo = (player: "p1" | "p2") => {
		const pokemon = battleState[player].active;
		const pokemonFromRequest = battleState[player].request?.side.pokemon[0];

		if (!pokemon) return <div>No active Pokémon</div>;

		const sprite = getSprite(pokemon, player);
		const item = pokemonFromRequest?.item
			? battleEngineRef.current?.getItem(pokemonFromRequest.item)
			: null;
		const ability = pokemonFromRequest?.baseAbility
			? battleEngineRef.current?.getAbility(pokemonFromRequest.baseAbility)
			: null;

		// Extract HP information from condition
		const { currentHP, maxHP, status } = parseCondition(pokemon);

		// Calculate HP percentage
		const hpPercentage = maxHP > 0 ? (currentHP / maxHP) * 100 : 0;
		let hpColor = "bg-green-500"; // Green
		if (hpPercentage <= 50) hpColor = "bg-yellow-500"; // Yellow
		if (hpPercentage <= 20) hpColor = "bg-red-500"; // Red

		return (
			<div className="mb-5">
				<div className="flex items-center mb-3">
					<img
						src={sprite?.url}
						alt={pokemon.name}
						className="w-24 h-24 mr-3"
					/>
					<div>
						<h3 className="text-lg font-semibold">{pokemon.name}</h3>
						{pokemon.types && (
							<div className="flex gap-1 mt-1">
								{pokemon.types.map((type) => (
									<Badge
										key={type}
										variant="secondary"
										className={`${TYPE_COLORS[type]} text-white text-xs px-2 py-0`}
									>
										{type}
									</Badge>
								))}
							</div>
						)}
					</div>
				</div>

				<div className="mb-3">
					<div className="flex justify-between mb-1">
						<span className="font-medium">HP:</span>
						<span className="font-medium">
							{currentHP}/{maxHP} ({Math.round(hpPercentage)}%)
						</span>
					</div>
					<div className="w-full h-3 bg-gray-200 rounded-full overflow-hidden">
						<div
							className={`h-full ${hpColor} transition-all duration-300`}
							style={{ width: `${hpPercentage}%` }}
						/>
					</div>
				</div>

				<div className="flex flex-col gap-1 mb-1">
					{item && (
						<div className="flex justify-between">
							<span className="font-medium">Item:</span>

							<Tooltip>
								<TooltipTrigger asChild>
									<span className="font-medium">{item.name}</span>
								</TooltipTrigger>
								<TooltipContent>
									<span>{item.desc}</span>
								</TooltipContent>
							</Tooltip>
						</div>
					)}
					{ability && (
						<div className="flex justify-between">
							<span className="font-medium">Ability:</span>

							<Tooltip>
								<TooltipTrigger asChild>
									<span className="font-medium">{ability.name}</span>
								</TooltipTrigger>
								<TooltipContent>
									<span>{ability.desc}</span>
								</TooltipContent>
							</Tooltip>
						</div>
					)}
				</div>

				<div className="flex flex-wrap gap-2">
					{status && (
						<div
							className={`inline-block px-2 py-1 rounded text-xs font-semibold ${getStatusClass(status)}`}
						>
							{getStatusName(status)}
						</div>
					)}
				</div>
			</div>
		);
	};

	// Render available moves for a player
	const renderMoves = (player: "p1" | "p2") => {
		const request = battleState[player].request;
		if (!request || !request.active || !request.active[0]) {
			return <div>No moves available</div>;
		}

		const active = request.active[0];
		const moves = active.moves || [];
		const selectedMove = battleState[player].selectedMove;

		return (
			<div className="mt-5">
				<h4 className="text-md font-semibold mb-3">Available Moves</h4>
				<div className="grid grid-cols-2 gap-2">
					{moves.map((move, index) => {
						// Get move details if battleEngine is available
						const moveData = battleEngineRef.current?.getMoveData(move.id);
						if (!moveData) {
							return null;
						}

						return (
							<BattleMoveButton
								key={move.id}
								moveDetails={move}
								// @ts-ignore - The type error is due to a mismatch between @pkmn/sim and @pkmn/dex-types
								moveData={moveData}
								isSelected={selectedMove === index + 1}
								onClick={() => {
									if (player === "p1") {
										handleP1MoveSelect(index + 1);
									} else {
										handleP2MoveSelect(index + 1);
									}
								}}
								disabled={move.disabled}
							/>
						);
					})}
				</div>
			</div>
		);
	};

	// Render battle logs
	const renderBattleLogs = () => {
		return (
			<div className="h-full flex flex-col">
				<h3 className="text-lg font-semibold mb-3">Battle Log</h3>
				<pre className="text-sm font-medium bg-green-100 border-green-200">
					{format}
				</pre>
				<div className="flex-1 overflow-y-auto max-h-[400px] p-2.5 border border-gray-200 rounded bg-gray-50">
					{battleState.logs.map((log: string, index: number) => (
						<div
							key={`log-${index}-${Date.now()}`}
							className="mb-1"
							// biome-ignore lint/security/noDangerouslySetInnerHtml: <explanation>
							dangerouslySetInnerHTML={{ __html: log }}
						/>
					))}
				</div>
			</div>
		);
	};

	return (
		<div className="flex flex-col w-full max-w-7xl mx-auto p-6 bg-gradient-to-b from-gray-50 to-gray-100 rounded-xl shadow-lg">
			<div className="text-center mb-6">
				<div className="flex justify-center items-center gap-4 mt-2">
					<Badge
						variant="outline"
						className="px-4 py-1.5 text-sm font-medium transition-colors"
					>
						Turn: {battleState.turn}
					</Badge>
					<Badge
						variant="secondary"
						className="px-4 py-1.5 text-sm font-medium"
					>
						{battleState.status}
					</Badge>
					{battleState.weather !== "none" && (
						<Badge
							variant="outline"
							className="px-4 py-1.5 text-sm font-medium bg-blue-100 border-blue-200"
						>
							{battleState.weather}
						</Badge>
					)}
				</div>
			</div>

			<div className="grid grid-cols-1 lg:grid-cols-[1.2fr_2fr_1.2fr] gap-6">
				<div className="bg-white p-5 rounded-xl shadow-sm border border-gray-100 hover:shadow-md transition-shadow">
					<h3 className="text-xl font-bold mb-4 text-indigo-800">{p1Name}</h3>
					{renderPokemonInfo("p1")}
					{renderMoves("p1")}
				</div>

				<div className="bg-white p-5 rounded-xl shadow-sm border border-gray-100 hover:shadow-md transition-shadow">
					{renderBattleLogs()}
				</div>

				<div className="bg-white p-5 rounded-xl shadow-sm border border-gray-100 hover:shadow-md transition-shadow">
					<h3 className="text-xl font-bold mb-4 text-indigo-800">{p2Name}</h3>
					{renderPokemonInfo("p2")}
					{renderMoves("p2")}
				</div>
			</div>
		</div>
	);
}


---
app/components/GenerationSelector.tsx
---
import { useSettings } from "@/app/store/settings";
import {
	Select,
	SelectContent,
	SelectItem,
	SelectTrigger,
	SelectValue,
} from "@/components/ui/select";
import type { GenerationNum } from "@pkmn/types";

export function GenerationSelector() {
	const { generation, setGeneration } = useSettings();

	const generations = Array.from(
		{ length: 9 },
		(_, i) => (i + 1) as GenerationNum,
	);

	return (
		<Select
			value={generation.toString()}
			onValueChange={(value) =>
				setGeneration(Number.parseInt(value) as GenerationNum)
			}
		>
			<SelectTrigger className="w-[180px]">
				<SelectValue placeholder="Select Generation" />
			</SelectTrigger>
			<SelectContent>
				{generations.map((gen) => (
					<SelectItem key={gen} value={gen.toString()}>
						Generation {gen}
					</SelectItem>
				))}
			</SelectContent>
		</Select>
	);
}


---
app/components/MoveButton.tsx
---
import React from "react";

type MoveButtonProps = {
	move: string;
	isSelected: boolean;
	onClick: () => void;
	disabled?: boolean;
};

/**
 * Pure UI component for a single move button
 */
export default function MoveButton({
	move,
	isSelected,
	onClick,
	disabled = false,
}: MoveButtonProps) {
	return (
		<button
			type="button"
			onClick={onClick}
			disabled={disabled}
			className={`
        py-2 px-3 rounded text-sm capitalize border
        ${
					isSelected
						? "bg-green-500 text-white border-green-600"
						: "bg-white hover:bg-gray-100 border-gray-300"
				}
        ${disabled ? "opacity-50 cursor-not-allowed" : "cursor-pointer"}
      `}
		>
			{move.replace(/-/g, " ")}
		</button>
	);
}


---
app/components/MoveList.tsx
---
import React from "react";
import MoveButton from "./MoveButton";

type MoveListProps = {
	moves: string[];
	selectedMove?: string;
	onSelectMove?: (move: string) => void;
	disabled?: boolean;
	title?: string;
	className?: string;
};

/**
 * Pure UI component for displaying a grid of move buttons
 */
export default function MoveList({
	moves,
	selectedMove,
	onSelectMove,
	disabled = false,
	title = "Moves",
	className = "",
}: MoveListProps) {
	return (
		<div className={`p-4 ${className}`}>
			<h4 className="font-medium mb-2">{title}:</h4>

			{moves.length === 0 ? (
				<p className="text-sm italic">No moves available</p>
			) : (
				<div className="grid grid-cols-2 gap-2">
					{moves.map((move) => (
						<MoveButton
							key={move}
							move={move}
							isSelected={selectedMove === move}
							onClick={() => onSelectMove?.(move)}
							disabled={disabled}
						/>
					))}
				</div>
			)}
		</div>
	);
}


---
app/components/PokemonCard.tsx
---
import { Card, CardContent, CardHeader } from "@/components/ui/card";
import { cn } from "@/lib/utils";
import MoveList from "./MoveList";
import type { PokemonWithMoves } from "../utils/pokemonUtils";
import { Badge } from "./ui/badge";
import { TYPE_COLORS } from "@/lib/constants";

type PokemonCardProps = {
	pokemon: PokemonWithMoves;
	side?: "user" | "opponent";
	className?: string;
	showMoves?: boolean;
	selectedMove?: string;
	onSelectMove?: (move: string) => void;
	disabledMoves?: boolean;
	movesTitle?: string;
};

/**
 * Reusable component to display a single Pokémon and optionally its moves
 */
export default function PokemonCard({
	pokemon,
	side = "user",
	className = "",
	showMoves = false,
	selectedMove = "",
	onSelectMove,
	disabledMoves = false,
	movesTitle,
}: PokemonCardProps) {
	const { pokemon: pokemonData, moves } = pokemon;

	const bgColor =
		side === "user"
			? "from-blue-500/10 to-blue-500/5"
			: "from-red-500/10 to-red-500/5";
	const glowColor =
		side === "user"
			? "from-blue-500/25 via-blue-500/5 to-transparent"
			: "from-red-500/25 via-red-500/5 to-transparent";
	const defaultMovesTitle = side === "user" ? "Your Moves" : "Opponent Moves";

	const handleMoveSelect = (move: string) => {
		if (onSelectMove) {
			onSelectMove(move);
		}
	};

	return (
		<Card
			className={cn(
				"overflow-hidden transition-all duration-200 backdrop-blur-sm bg-gradient-to-b",
				bgColor,
				className,
			)}
		>
			<CardHeader className="p-4">
				<div className="flex flex-col items-center gap-2 mb-2">
					<div className="flex items-center justify-between w-full">
						<span className="text-sm text-muted-foreground">
							#{pokemonData.num.toString().padStart(3, "0")}
						</span>
						<span className="text-xl font-semibold capitalize tracking-tight mx-2">
							{pokemonData.name.replace(/-/g, " ")}
						</span>
						<div className="flex gap-1">
							{pokemonData.types.map((type) => (
								<Badge
									key={type}
									variant="secondary"
									className={`${TYPE_COLORS[type]} text-white text-xs px-2 py-0`}
								>
									{type}
								</Badge>
							))}
						</div>
					</div>
				</div>
			</CardHeader>
			<CardContent className="p-6 pt-0">
				<div className="flex flex-col items-center">
					<div className="relative w-40 h-40 flex items-center justify-center group">
						{/* Glow effect */}
						<div
							className={cn(
								"absolute inset-0 bg-gradient-radial opacity-0 group-hover:opacity-100 transition-opacity duration-300 blur-2xl -z-10",
								glowColor,
							)}
						/>
						<img
							src={pokemonData.sprite}
							alt={pokemonData.name}
							className="w-full h-full object-contain relative z-10 drop-shadow-xl transform group-hover:scale-110 transition-all duration-300 will-change-transform"
							loading="lazy"
						/>
					</div>
				</div>

				{/* Show moves if requested */}
				{showMoves && moves.length > 0 && (
					<div className="mt-6">
						<MoveList
							moves={moves}
							selectedMove={selectedMove}
							onSelectMove={handleMoveSelect}
							disabled={disabledMoves}
							title={movesTitle || defaultMovesTitle}
							className="mt-2"
						/>
					</div>
				)}
			</CardContent>
		</Card>
	);
}


---
app/components/PokemonSelector.tsx
---
import { useState, useEffect, useMemo, useCallback } from "react";
import { Generations, type Specie } from "@pkmn/data";
import { Teams } from "@pkmn/sim";
import { Dex } from "@pkmn/dex";
import { Sprites } from "@pkmn/img";
import { TYPE_COLORS } from "@/lib/constants";
import { getRandomMovesForPokemon } from "../utils/pokemonUtils";
import PokemonCard from "./PokemonCard";
import { Card, CardContent } from "@/components/ui/card";
import { ScrollArea } from "@/components/ui/scroll-area";
import { Badge } from "@/components/ui/badge";
import { Loader2, Swords } from "lucide-react";
import { useBattleStore } from "@/app/store/battle-store";
import { useRouter } from "next/navigation";
import { useSettings } from "@/app/store/settings";
import {
	Select,
	SelectContent,
	SelectItem,
	SelectTrigger,
	SelectValue,
} from "@/components/ui/select";
import { Button } from "@/components/ui/button";

export type PokemonData = Specie & {
	sprite: string;
};

/**
 * Component for selecting a single Pokemon
 */
export default function PokemonSelector() {
	const router = useRouter();
	const {
		setSelectedPokemon,
		setSelectedMoves,
		selectedMoves,
		selectedPokemon,
		setOpponentPokemon,
		setOpponentMoves,
		setP1Team,
		setP2Team,
	} = useBattleStore();
	const [allPokemon, setAllPokemon] = useState<PokemonData[]>([]);
	const [selectedPokemonId, setSelectedPokemonId] = useState<string>("");
	const [isLoading, setIsLoading] = useState(true);
	const [isLoadingMoves, setIsLoadingMoves] = useState(false);
	const [isStartingBattle, setIsStartingBattle] = useState(false);
	const { generation } = useSettings();

	// Memoize the sorted Pokemon list
	const sortedPokemon = useMemo(() => {
		return [...allPokemon].sort((a, b) => a.num - b.num);
	}, [allPokemon]);

	useEffect(() => {
		// Initialize the generations using the Dex
		const fetchPokemonData = async () => {
			try {
				const gens = new Generations(Dex);
				const gen = gens.get(generation);

				// Get all Pokemon from Gen 1
				const pokemonList = Array.from(gen.species).map((species) => {
					// Get sprite URL using @pkmn/img
					const spriteUrl = Sprites.getPokemon(species.name, {
						gen: generation,
						side: "p2",
					}).url;

					return {
						...species,
						sprite: spriteUrl,
					};
				});

				// @ts-ignore
				setAllPokemon(pokemonList);
				setIsLoading(false);
			} catch (error) {
				console.error("Error loading Pokemon data:", error);
				setIsLoading(false);
			}
		};

		fetchPokemonData();
	}, [generation]);

	const getRandomMoves = useCallback(
		async (pokemonId: string) => {
			setIsLoadingMoves(true);
			try {
				const pokemon = allPokemon.find((p) => p.id === pokemonId);
				if (!pokemon) {
					throw new Error(`Pokemon ${pokemonId} not found`);
				}
				const moves = await getRandomMovesForPokemon(pokemon);

				if (pokemon) {
					setSelectedMoves(moves);
					setSelectedPokemon(pokemon);
				}
			} catch (error) {
				console.error("Error getting moves:", error);
				setSelectedMoves([]);
				setSelectedPokemon(null);
			} finally {
				setIsLoadingMoves(false);
			}
		},
		[allPokemon, setSelectedMoves, setSelectedPokemon],
	);

	const handleSelectChange = useCallback(
		async (value: string) => {
			setSelectedPokemonId(value);

			if (value) {
				await getRandomMoves(value);
			} else {
				setSelectedMoves([]);
				setSelectedPokemon(null);
			}
		},
		[getRandomMoves, setSelectedMoves, setSelectedPokemon],
	);

	const handleStartBattle = useCallback(async () => {
		if (!selectedPokemon) return;

		setIsStartingBattle(true);
		try {
			// Select a random opponent
			const availablePokemon = allPokemon.filter(
				(p) => p.id !== selectedPokemon.id,
			);
			const randomOpponent =
				availablePokemon[Math.floor(Math.random() * availablePokemon.length)];

			// Get moves for the opponent
			const opponentMoves = await getRandomMovesForPokemon(randomOpponent);

			// Set opponent data
			setOpponentPokemon(randomOpponent);
			setOpponentMoves(opponentMoves);

			// Generate team strings for both players
			// @ts-ignore
			const p1Team = Teams.exportSet({
				name: selectedPokemon.name,
				species: selectedPokemon.baseSpecies,
				moves: selectedMoves,
			});

			// @ts-ignore
			const p2Team = Teams.exportSet({
				name: randomOpponent.name,
				species: randomOpponent.baseSpecies,
				moves: opponentMoves,
			});

			setP1Team(p1Team);
			setP2Team(p2Team);

			// Navigate to battle page
			router.push("/battle");
		} catch (error) {
			console.error("Error starting battle:", error);
		} finally {
			setIsStartingBattle(false);
		}
	}, [
		selectedPokemon,
		allPokemon,
		setOpponentPokemon,
		setOpponentMoves,
		selectedMoves,
		setP1Team,
		setP2Team,
		router,
	]);

	if (isLoading) {
		return (
			<div className="flex items-center justify-center p-4">
				<Loader2 className="h-6 w-6 animate-spin" />
				<span className="ml-2">Loading Pokemon data...</span>
			</div>
		);
	}

	// Find the selected Pokemon object
	const selectedPokemonData = selectedPokemonId
		? allPokemon.find((p) => p.id === selectedPokemonId)
		: null;

	return (
		<div className="w-full space-y-6">
			<Select value={selectedPokemonId} onValueChange={handleSelectChange}>
				<SelectTrigger className="w-full">
					<SelectValue placeholder="Select a Pokemon..." />
				</SelectTrigger>
				<SelectContent className="max-h-[300px]">
					<ScrollArea className="h-[300px]">
						{sortedPokemon.map((pokemon) => (
							<SelectItem
								key={pokemon.id}
								value={pokemon.id}
								className="flex items-center gap-2 py-2 hover:bg-accent/50 transition-colors"
							>
								<img
									src={pokemon.sprite}
									alt={pokemon.name}
									className="w-10 h-10 object-contain"
									loading="lazy"
								/>
								<span className="text-sm text-muted-foreground mr-1">
									#{pokemon.num.toString().padStart(3, "0")}
								</span>
								<span className="font-medium capitalize">
									{pokemon.name.replace(/-/g, " ")}
								</span>
								<div className="flex gap-1 ml-auto">
									{pokemon.types.map((type) => (
										<Badge
											key={type}
											variant="secondary"
											className={`${TYPE_COLORS[type]} text-white text-xs px-2 py-0`}
										>
											{type}
										</Badge>
									))}
								</div>
							</SelectItem>
						))}
					</ScrollArea>
				</SelectContent>
			</Select>

			{selectedPokemonData && (
				<Card className="overflow-hidden border-2">
					<CardContent className="pt-6">
						<PokemonCard
							pokemon={{
								pokemon: selectedPokemonData,
								moves: selectedMoves,
							}}
							className="mb-4"
							showMoves={true}
							disabledMoves={isLoadingMoves}
						/>

						<div className="flex gap-4">
							<Button
								onClick={handleStartBattle}
								disabled={
									isStartingBattle ||
									!selectedPokemonId ||
									!selectedMoves.length
								}
								variant="default"
								className="flex-1"
							>
								{isStartingBattle ? (
									<>
										<Loader2 className="mr-2 h-4 w-4 animate-spin" />
										Starting battle...
									</>
								) : (
									<>
										<Swords className="mr-2 h-4 w-4" />
										Start Battle
									</>
								)}
							</Button>
						</div>
					</CardContent>
				</Card>
			)}
		</div>
	);
}


---
app/components/ui/badge.tsx
---
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const badgeVariants = cva(
  "inline-flex items-center justify-center rounded-md border px-2 py-0.5 text-xs font-medium w-fit whitespace-nowrap shrink-0 [&>svg]:size-3 gap-1 [&>svg]:pointer-events-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive transition-[color,box-shadow] overflow-hidden",
  {
    variants: {
      variant: {
        default:
          "border-transparent bg-primary text-primary-foreground [a&]:hover:bg-primary/90",
        secondary:
          "border-transparent bg-secondary text-secondary-foreground [a&]:hover:bg-secondary/90",
        destructive:
          "border-transparent bg-destructive text-white [a&]:hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40",
        outline:
          "text-foreground [a&]:hover:bg-accent [a&]:hover:text-accent-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

function Badge({
  className,
  variant,
  asChild = false,
  ...props
}: React.ComponentProps<"span"> &
  VariantProps<typeof badgeVariants> & { asChild?: boolean }) {
  const Comp = asChild ? Slot : "span"

  return (
    <Comp
      data-slot="badge"
      className={cn(badgeVariants({ variant }), className)}
      {...props}
    />
  )
}

export { Badge, badgeVariants }


---
app/components/ui/button.tsx
---
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-[color,box-shadow] disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
  {
    variants: {
      variant: {
        default:
          "bg-primary text-primary-foreground shadow-xs hover:bg-primary/90",
        destructive:
          "bg-destructive text-white shadow-xs hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40",
        outline:
          "border border-input bg-background shadow-xs hover:bg-accent hover:text-accent-foreground",
        secondary:
          "bg-secondary text-secondary-foreground shadow-xs hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2 has-[>svg]:px-3",
        sm: "h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5",
        lg: "h-10 rounded-md px-6 has-[>svg]:px-4",
        icon: "size-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

function Button({
  className,
  variant,
  size,
  asChild = false,
  ...props
}: React.ComponentProps<"button"> &
  VariantProps<typeof buttonVariants> & {
    asChild?: boolean
  }) {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      data-slot="button"
      className={cn(buttonVariants({ variant, size, className }))}
      {...props}
    />
  )
}

export { Button, buttonVariants }


---
app/components/ui/card.tsx
---
import * as React from "react"

import { cn } from "@/lib/utils"

function Card({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card"
      className={cn(
        "bg-card text-card-foreground flex flex-col gap-6 rounded-xl border py-6 shadow-sm",
        className
      )}
      {...props}
    />
  )
}

function CardHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-header"
      className={cn("flex flex-col gap-1.5 px-6", className)}
      {...props}
    />
  )
}

function CardTitle({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-title"
      className={cn("leading-none font-semibold", className)}
      {...props}
    />
  )
}

function CardDescription({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

function CardContent({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-content"
      className={cn("px-6", className)}
      {...props}
    />
  )
}

function CardFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-footer"
      className={cn("flex items-center px-6", className)}
      {...props}
    />
  )
}

export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }


---
app/components/ui/command.tsx
---
"use client"

import * as React from "react"
import { Command as CommandPrimitive } from "cmdk"
import { SearchIcon } from "lucide-react"

import { cn } from "@/lib/utils"
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog"

function Command({
  className,
  ...props
}: React.ComponentProps<typeof CommandPrimitive>) {
  return (
    <CommandPrimitive
      data-slot="command"
      className={cn(
        "bg-popover text-popover-foreground flex h-full w-full flex-col overflow-hidden rounded-md",
        className
      )}
      {...props}
    />
  )
}

function CommandDialog({
  title = "Command Palette",
  description = "Search for a command to run...",
  children,
  ...props
}: React.ComponentProps<typeof Dialog> & {
  title?: string
  description?: string
}) {
  return (
    <Dialog {...props}>
      <DialogHeader className="sr-only">
        <DialogTitle>{title}</DialogTitle>
        <DialogDescription>{description}</DialogDescription>
      </DialogHeader>
      <DialogContent className="overflow-hidden p-0">
        <Command className="[&_[cmdk-group-heading]]:text-muted-foreground **:data-[slot=command-input-wrapper]:h-12 [&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group]]:px-2 [&_[cmdk-group]:not([hidden])_~[cmdk-group]]:pt-0 [&_[cmdk-input-wrapper]_svg]:h-5 [&_[cmdk-input-wrapper]_svg]:w-5 [&_[cmdk-input]]:h-12 [&_[cmdk-item]]:px-2 [&_[cmdk-item]]:py-3 [&_[cmdk-item]_svg]:h-5 [&_[cmdk-item]_svg]:w-5">
          {children}
        </Command>
      </DialogContent>
    </Dialog>
  )
}

function CommandInput({
  className,
  ...props
}: React.ComponentProps<typeof CommandPrimitive.Input>) {
  return (
    <div
      data-slot="command-input-wrapper"
      className="flex h-9 items-center gap-2 border-b px-3"
    >
      <SearchIcon className="size-4 shrink-0 opacity-50" />
      <CommandPrimitive.Input
        data-slot="command-input"
        className={cn(
          "placeholder:text-muted-foreground flex h-10 w-full rounded-md bg-transparent py-3 text-sm outline-hidden disabled:cursor-not-allowed disabled:opacity-50",
          className
        )}
        {...props}
      />
    </div>
  )
}

function CommandList({
  className,
  ...props
}: React.ComponentProps<typeof CommandPrimitive.List>) {
  return (
    <CommandPrimitive.List
      data-slot="command-list"
      className={cn(
        "max-h-[300px] scroll-py-1 overflow-x-hidden overflow-y-auto",
        className
      )}
      {...props}
    />
  )
}

function CommandEmpty({
  ...props
}: React.ComponentProps<typeof CommandPrimitive.Empty>) {
  return (
    <CommandPrimitive.Empty
      data-slot="command-empty"
      className="py-6 text-center text-sm"
      {...props}
    />
  )
}

function CommandGroup({
  className,
  ...props
}: React.ComponentProps<typeof CommandPrimitive.Group>) {
  return (
    <CommandPrimitive.Group
      data-slot="command-group"
      className={cn(
        "text-foreground [&_[cmdk-group-heading]]:text-muted-foreground overflow-hidden p-1 [&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:py-1.5 [&_[cmdk-group-heading]]:text-xs [&_[cmdk-group-heading]]:font-medium",
        className
      )}
      {...props}
    />
  )
}

function CommandSeparator({
  className,
  ...props
}: React.ComponentProps<typeof CommandPrimitive.Separator>) {
  return (
    <CommandPrimitive.Separator
      data-slot="command-separator"
      className={cn("bg-border -mx-1 h-px", className)}
      {...props}
    />
  )
}

function CommandItem({
  className,
  ...props
}: React.ComponentProps<typeof CommandPrimitive.Item>) {
  return (
    <CommandPrimitive.Item
      data-slot="command-item"
      className={cn(
        "data-[selected=true]:bg-accent data-[selected=true]:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[disabled=true]:pointer-events-none data-[disabled=true]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    />
  )
}

function CommandShortcut({
  className,
  ...props
}: React.ComponentProps<"span">) {
  return (
    <span
      data-slot="command-shortcut"
      className={cn(
        "text-muted-foreground ml-auto text-xs tracking-widest",
        className
      )}
      {...props}
    />
  )
}

export {
  Command,
  CommandDialog,
  CommandInput,
  CommandList,
  CommandEmpty,
  CommandGroup,
  CommandItem,
  CommandShortcut,
  CommandSeparator,
}


---
app/components/ui/dialog.tsx
---
"use client"

import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"
import { XIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Dialog({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Root>) {
  return <DialogPrimitive.Root data-slot="dialog" {...props} />
}

function DialogTrigger({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Trigger>) {
  return <DialogPrimitive.Trigger data-slot="dialog-trigger" {...props} />
}

function DialogPortal({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Portal>) {
  return <DialogPrimitive.Portal data-slot="dialog-portal" {...props} />
}

function DialogClose({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Close>) {
  return <DialogPrimitive.Close data-slot="dialog-close" {...props} />
}

function DialogOverlay({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Overlay>) {
  return (
    <DialogPrimitive.Overlay
      data-slot="dialog-overlay"
      className={cn(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/80",
        className
      )}
      {...props}
    />
  )
}

function DialogContent({
  className,
  children,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Content>) {
  return (
    <DialogPortal data-slot="dialog-portal">
      <DialogOverlay />
      <DialogPrimitive.Content
        data-slot="dialog-content"
        className={cn(
          "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 sm:max-w-lg",
          className
        )}
        {...props}
      >
        {children}
        <DialogPrimitive.Close className="ring-offset-background focus:ring-ring data-[state=open]:bg-accent data-[state=open]:text-muted-foreground absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4">
          <XIcon />
          <span className="sr-only">Close</span>
        </DialogPrimitive.Close>
      </DialogPrimitive.Content>
    </DialogPortal>
  )
}

function DialogHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="dialog-header"
      className={cn("flex flex-col gap-2 text-center sm:text-left", className)}
      {...props}
    />
  )
}

function DialogFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="dialog-footer"
      className={cn(
        "flex flex-col-reverse gap-2 sm:flex-row sm:justify-end",
        className
      )}
      {...props}
    />
  )
}

function DialogTitle({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Title>) {
  return (
    <DialogPrimitive.Title
      data-slot="dialog-title"
      className={cn("text-lg leading-none font-semibold", className)}
      {...props}
    />
  )
}

function DialogDescription({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Description>) {
  return (
    <DialogPrimitive.Description
      data-slot="dialog-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

export {
  Dialog,
  DialogClose,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogOverlay,
  DialogPortal,
  DialogTitle,
  DialogTrigger,
}


---
app/components/ui/popover.tsx
---
"use client"

import * as React from "react"
import * as PopoverPrimitive from "@radix-ui/react-popover"

import { cn } from "@/lib/utils"

function Popover({
  ...props
}: React.ComponentProps<typeof PopoverPrimitive.Root>) {
  return <PopoverPrimitive.Root data-slot="popover" {...props} />
}

function PopoverTrigger({
  ...props
}: React.ComponentProps<typeof PopoverPrimitive.Trigger>) {
  return <PopoverPrimitive.Trigger data-slot="popover-trigger" {...props} />
}

function PopoverContent({
  className,
  align = "center",
  sideOffset = 4,
  ...props
}: React.ComponentProps<typeof PopoverPrimitive.Content>) {
  return (
    <PopoverPrimitive.Portal>
      <PopoverPrimitive.Content
        data-slot="popover-content"
        align={align}
        sideOffset={sideOffset}
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 w-72 rounded-md border p-4 shadow-md outline-hidden",
          className
        )}
        {...props}
      />
    </PopoverPrimitive.Portal>
  )
}

function PopoverAnchor({
  ...props
}: React.ComponentProps<typeof PopoverPrimitive.Anchor>) {
  return <PopoverPrimitive.Anchor data-slot="popover-anchor" {...props} />
}

export { Popover, PopoverTrigger, PopoverContent, PopoverAnchor }


---
app/components/ui/scroll-area.tsx
---
"use client"

import * as React from "react"
import * as ScrollAreaPrimitive from "@radix-ui/react-scroll-area"

import { cn } from "@/lib/utils"

function ScrollArea({
  className,
  children,
  ...props
}: React.ComponentProps<typeof ScrollAreaPrimitive.Root>) {
  return (
    <ScrollAreaPrimitive.Root
      data-slot="scroll-area"
      className={cn("relative", className)}
      {...props}
    >
      <ScrollAreaPrimitive.Viewport
        data-slot="scroll-area-viewport"
        className="ring-ring/10 dark:ring-ring/20 dark:outline-ring/40 outline-ring/50 size-full rounded-[inherit] transition-[color,box-shadow] focus-visible:ring-4 focus-visible:outline-1"
      >
        {children}
      </ScrollAreaPrimitive.Viewport>
      <ScrollBar />
      <ScrollAreaPrimitive.Corner />
    </ScrollAreaPrimitive.Root>
  )
}

function ScrollBar({
  className,
  orientation = "vertical",
  ...props
}: React.ComponentProps<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>) {
  return (
    <ScrollAreaPrimitive.ScrollAreaScrollbar
      data-slot="scroll-area-scrollbar"
      orientation={orientation}
      className={cn(
        "flex touch-none p-px transition-colors select-none",
        orientation === "vertical" &&
          "h-full w-2.5 border-l border-l-transparent",
        orientation === "horizontal" &&
          "h-2.5 flex-col border-t border-t-transparent",
        className
      )}
      {...props}
    >
      <ScrollAreaPrimitive.ScrollAreaThumb
        data-slot="scroll-area-thumb"
        className="bg-border relative flex-1 rounded-full"
      />
    </ScrollAreaPrimitive.ScrollAreaScrollbar>
  )
}

export { ScrollArea, ScrollBar }


---
app/components/ui/select.tsx
---
"use client"

import * as React from "react"
import * as SelectPrimitive from "@radix-ui/react-select"
import { CheckIcon, ChevronDownIcon, ChevronUpIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Select({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Root>) {
  return <SelectPrimitive.Root data-slot="select" {...props} />
}

function SelectGroup({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Group>) {
  return <SelectPrimitive.Group data-slot="select-group" {...props} />
}

function SelectValue({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Value>) {
  return <SelectPrimitive.Value data-slot="select-value" {...props} />
}

function SelectTrigger({
  className,
  children,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Trigger>) {
  return (
    <SelectPrimitive.Trigger
      data-slot="select-trigger"
      className={cn(
        "border-input data-[placeholder]:text-muted-foreground [&_svg:not([class*='text-'])]:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive flex h-9 w-fit items-center justify-between gap-2 rounded-md border bg-transparent px-3 py-2 text-sm whitespace-nowrap shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 *:data-[slot=select-value]:line-clamp-1 *:data-[slot=select-value]:flex *:data-[slot=select-value]:items-center *:data-[slot=select-value]:gap-2 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      {children}
      <SelectPrimitive.Icon asChild>
        <ChevronDownIcon className="size-4 opacity-50" />
      </SelectPrimitive.Icon>
    </SelectPrimitive.Trigger>
  )
}

function SelectContent({
  className,
  children,
  position = "popper",
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Content>) {
  return (
    <SelectPrimitive.Portal>
      <SelectPrimitive.Content
        data-slot="select-content"
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 relative z-50 max-h-(--radix-select-content-available-height) min-w-[8rem] overflow-x-hidden overflow-y-auto rounded-md border shadow-md",
          position === "popper" &&
            "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
          className
        )}
        position={position}
        {...props}
      >
        <SelectScrollUpButton />
        <SelectPrimitive.Viewport
          className={cn(
            "p-1",
            position === "popper" &&
              "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)] scroll-my-1"
          )}
        >
          {children}
        </SelectPrimitive.Viewport>
        <SelectScrollDownButton />
      </SelectPrimitive.Content>
    </SelectPrimitive.Portal>
  )
}

function SelectLabel({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Label>) {
  return (
    <SelectPrimitive.Label
      data-slot="select-label"
      className={cn("px-2 py-1.5 text-sm font-medium", className)}
      {...props}
    />
  )
}

function SelectItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Item>) {
  return (
    <SelectPrimitive.Item
      data-slot="select-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground relative flex w-full cursor-default items-center gap-2 rounded-sm py-1.5 pr-8 pl-2 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4 *:[span]:last:flex *:[span]:last:items-center *:[span]:last:gap-2",
        className
      )}
      {...props}
    >
      <span className="absolute right-2 flex size-3.5 items-center justify-center">
        <SelectPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </SelectPrimitive.ItemIndicator>
      </span>
      <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
    </SelectPrimitive.Item>
  )
}

function SelectSeparator({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Separator>) {
  return (
    <SelectPrimitive.Separator
      data-slot="select-separator"
      className={cn("bg-border pointer-events-none -mx-1 my-1 h-px", className)}
      {...props}
    />
  )
}

function SelectScrollUpButton({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollUpButton>) {
  return (
    <SelectPrimitive.ScrollUpButton
      data-slot="select-scroll-up-button"
      className={cn(
        "flex cursor-default items-center justify-center py-1",
        className
      )}
      {...props}
    >
      <ChevronUpIcon className="size-4" />
    </SelectPrimitive.ScrollUpButton>
  )
}

function SelectScrollDownButton({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollDownButton>) {
  return (
    <SelectPrimitive.ScrollDownButton
      data-slot="select-scroll-down-button"
      className={cn(
        "flex cursor-default items-center justify-center py-1",
        className
      )}
      {...props}
    >
      <ChevronDownIcon className="size-4" />
    </SelectPrimitive.ScrollDownButton>
  )
}

export {
  Select,
  SelectContent,
  SelectGroup,
  SelectItem,
  SelectLabel,
  SelectScrollDownButton,
  SelectScrollUpButton,
  SelectSeparator,
  SelectTrigger,
  SelectValue,
}


---
app/components/ui/tooltip.tsx
---
"use client"

import * as React from "react"
import * as TooltipPrimitive from "@radix-ui/react-tooltip"

import { cn } from "@/lib/utils"

function TooltipProvider({
  delayDuration = 0,
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Provider>) {
  return (
    <TooltipPrimitive.Provider
      data-slot="tooltip-provider"
      delayDuration={delayDuration}
      {...props}
    />
  )
}

function Tooltip({
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Root>) {
  return (
    <TooltipProvider>
      <TooltipPrimitive.Root data-slot="tooltip" {...props} />
    </TooltipProvider>
  )
}

function TooltipTrigger({
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Trigger>) {
  return <TooltipPrimitive.Trigger data-slot="tooltip-trigger" {...props} />
}

function TooltipContent({
  className,
  sideOffset = 0,
  children,
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Content>) {
  return (
    <TooltipPrimitive.Portal>
      <TooltipPrimitive.Content
        data-slot="tooltip-content"
        sideOffset={sideOffset}
        className={cn(
          "bg-primary text-primary-foreground animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 w-fit rounded-md px-3 py-1.5 text-xs text-balance",
          className
        )}
        {...props}
      >
        {children}
        <TooltipPrimitive.Arrow className="bg-primary fill-primary z-50 size-2.5 translate-y-[calc(-50%_-_2px)] rotate-45 rounded-[2px]" />
      </TooltipPrimitive.Content>
    </TooltipPrimitive.Portal>
  )
}

export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider }


---
app/services/battle-engine.ts
---
import { Battle } from "@pkmn/client";
import { Generations } from "@pkmn/data";
import {
    type ArgName,
    type ArgType,
    type BattleArgsKWArgType,
    Protocol,
} from "@pkmn/protocol";
import { TeamGenerators } from "@pkmn/randoms";
import {
    BattleStreams,
    Teams as DTeams,
    Dex,
    type ModdedDex,
    PRNG,
} from "@pkmn/sim";
import type { ObjectReadWriteStream } from "@pkmn/streams";
import { LogFormatter } from "@pkmn/view";
import { BattleEventEmitter, type BattleEventMap } from "./battle-event-emitter";
import type { BattleState, BattleOptions, PlayerDecision, PlayerRequest } from "./battle-types";
import { ManualPlayer } from "./player";

/**
 * Core battle engine that manages the battle state and logic
 */
export class BattleEngine {
    private battle: Battle;
    private streams: ReturnType<typeof BattleStreams.getPlayerStreams>;
    private p1Stream: ObjectReadWriteStream<string>;
    private p2Stream: ObjectReadWriteStream<string>;
    private formatter: LogFormatter;
    private prng: PRNG;
    private dex: ModdedDex;
    private gens: Generations;
    private format: string;
    private battleState: BattleState;
    private eventEmitter: BattleEventEmitter;
    private p1: ManualPlayer;
    private p2: ManualPlayer;

    /**
     * Create a battle engine
     * @param options - The battle options
     */
    constructor(options: BattleOptions) {
        this.format = options.format || "gen3randombattle";
        this.prng = new PRNG();
        this.dex = Dex.forFormat(this.format);
        // @ts-ignore
        this.gens = new Generations(Dex);
        this.eventEmitter = new BattleEventEmitter();

        // Set up team generators
        DTeams.setGeneratorFactory(TeamGenerators);

        // Initialize battle state
        this.battleState = {
            turn: 0,
            p1: {
                name: options.p1Name,
                active: null,
                team: [],
                request: null,
                selectedMove: null
            },
            p2: {
                name: options.p2Name,
                active: null,
                team: [],
                request: null,
                selectedMove: null
            },
            weather: "none",
            status: "Initializing battle...",
            logs: [],
            isComplete: false,
            winner: null
        };

        // Create battle streams
        this.streams = BattleStreams.getPlayerStreams(
            new BattleStreams.BattleStream(),
        );
        this.p1Stream = this.streams.p1;
        this.p2Stream = this.streams.p2;

        // Create battle instance
        this.battle = new Battle(this.gens);

        // Create formatter
        this.formatter = new LogFormatter("p1", this.battle);

        // Initialize players
        this.p1 = new ManualPlayer(
            this.p1Stream,
            false,
            options.p1Name,
            (request: PlayerRequest) => this.handlePlayerRequest("p1", request)
        );

        this.p2 = new ManualPlayer(
            this.p2Stream,
            false,
            options.p2Name,
            (request) => this.handlePlayerRequest("p2", request)
        );

        // Set up onBattleUpdate callback if provided
        if (options.onBattleUpdate) {
            this.on("stateUpdate", (state) => {

                if (options.onBattleUpdate) {
                    options.onBattleUpdate(this.getState());
                }
            });
        }

        // Start listening to the omniscient stream
        this.startBattleStream();
    }

    /**
     * Start the battle stream
     */
    private async startBattleStream(): Promise<void> {
        try {
            for await (const chunk of this.streams.omniscient) {
                for (const line of chunk.split("\n")) {
                    const { args, kwArgs } = Protocol.parseBattleLine(line);
                    const html = this.formatter.formatHTML(args, kwArgs);
                    const key = Protocol.key(args);

                    // Pre-processing
                    this.preProcess(key, args, kwArgs);

                    // Update battle state
                    this.battle.add(args, kwArgs);

                    // Post-processing
                    this.postProcess(key, args, kwArgs);

                    if (html) {
                        this.battleState.logs.push(html);
                    }
                }

                // Update battle
                this.battle.update();

                // Emit state update event
                this.eventEmitter.emit("stateUpdate", this.getState());
            }
        } catch (error) {
            console.error("Battle stream error:", error);
        }
    }

    /**
     * Pre-process battle events
     * @param key - The event key
     * @param args - The event arguments
     * @param kwArgs - The event keyword arguments
     */
    private preProcess(
        key: ArgName | undefined,
        args: ArgType,
        kwArgs: BattleArgsKWArgType,
    ): void {
        if (key === "|faint|") {
            const pokemonId = args[1] as string;
            this.handleFaint(pokemonId);
        }
    }

    /**
     * Post-process battle events
     * @param key - The event key
     * @param args - The event arguments
     * @param kwArgs - The event keyword arguments
     */
    private postProcess(
        key: ArgName | undefined,
        args: ArgType,
        kwArgs: BattleArgsKWArgType,
    ): void {
        if (key === "|teampreview|") {
            this.battleState.p1.team = [...this.battle.p1.team];
            this.battleState.p2.team = [...this.battle.p2.team];
            this.battleState.status = "Team preview";
        } else if (key === "|turn|") {
            this.battleState.turn = Number(args[1]);
            this.battleState.status = `Current Turn: ${this.battleState.turn}`;

            // Update active Pokémon
            this.battleState.p1.active = this.battle.p1.active[0] || null;
            this.battleState.p2.active = this.battle.p2.active[0] || null;

            // Emit turn start event
            this.eventEmitter.emit("turnStart", this.battleState.turn);
        } else if (key === "|-weather|") {
            const weather = args[1] as string;
            this.battleState.weather = weather;

            // Update status message based on weather
            let weatherText = "";
            switch (weather) {
                case "RainDance":
                    weatherText = "It's raining!";
                    break;
                case "Sandstorm":
                    weatherText = "A sandstorm is raging!";
                    break;
                case "SunnyDay":
                    weatherText = "The sunlight is strong!";
                    break;
                case "Hail":
                    weatherText = "It's hailing!";
                    break;
                case "none":
                    weatherText = "The weather cleared up!";
                    break;
                default:
                    weatherText = `Weather: ${weather}`;
            }
            this.battleState.status = weatherText;
        } else if (key === "|win|") {
            const winner = args[1] as string;
            this.battleState.isComplete = true;
            this.battleState.winner = winner;
            this.battleState.status = `${winner} has won the battle!`;

            // Emit battle end event
            this.eventEmitter.emit("battleEnd", {
                winner,
                state: this.getState()
            });
        }
    }

    /**
     * Handle a fainted Pokémon
     * @param pokemonId - The Pokémon ID
     */
    private handleFaint(pokemonId: string): void {
        console.log(`${pokemonId} has fainted!`);

        // Determine the winner if all Pokémon on one side have fainted
        const isDead = (player: "p1" | "p2") =>
            this.battle[player].team.every(p => p.fainted);

        if (pokemonId.startsWith("p1") && isDead("p1")) {
            this.battleState.winner = this.battleState.p2.name;
            this.battleState.isComplete = true;
            this.battleState.status = `${this.battleState.p2.name} has won the battle!`;

            // Emit battle end event
            this.eventEmitter.emit("battleEnd", {
                winner: this.battleState.p2.name,
                state: this.getState()
            });
        } else if (pokemonId.startsWith("p2") && isDead("p2")) {
            this.battleState.winner = this.battleState.p1.name;
            this.battleState.isComplete = true;
            this.battleState.status = `${this.battleState.p1.name} has won the battle!`;

            // Emit battle end event
            this.eventEmitter.emit("battleEnd", {
                winner: this.battleState.p1.name,
                state: this.getState()
            });
        }
    }

    /**
     * Handle a player request
     * @param player - The player ID
     * @param request - The request
     */
    private handlePlayerRequest(player: "p1" | "p2", request: PlayerRequest): void {
        // Store the request in battle state
        this.battleState[player].request = request;

        // Update active Pokémon if available
        // @ts-ignore
        if (request.active && request.side && request.side.pokemon) {
            const activePokemon = this.battle[player].active[0];
            if (activePokemon) {
                this.battleState[player].active = activePokemon;
            }

            // Update player teams
            if (request.side.pokemon) {
                this.battleState[player].team = request.side.pokemon;
            }
        }

        // Emit player request event
        this.eventEmitter.emit("playerRequest", { player, request });

        // Emit state update event
        this.eventEmitter.emit("stateUpdate", this.getState());
    }

    /**
     * Start the battle
     * @param p1Team - Optional team for player 1
     * @param p2Team - Optional team for player 2
     */
    startBattle(p1Team?: string, p2Team?: string): void {
        const spec = { formatid: this.format };

        // Generate random teams if needed
        const createTeam = () => {
            // Use the built-in team generator
            try {
                const generator = TeamGenerators.getTeamGenerator(this.format, this.prng);
                return DTeams.export(generator.getTeam());
            } catch (error) {
                console.error("Error generating random team:", error);
                return null;
            }
        };

        const p1TeamFinal = p1Team || createTeam();
        const p2TeamFinal = p2Team || createTeam();

        const p1spec = {
            name: this.battleState.p1.name,
            team: p1TeamFinal ? DTeams.import(p1TeamFinal) : null,
        };
        const p2spec = {
            name: this.battleState.p2.name,
            team: p2TeamFinal ? DTeams.import(p2TeamFinal) : null,
        };

        // Start the battle
        void this.streams.omniscient.write(`>start ${JSON.stringify(spec)}
>player p1 ${JSON.stringify(p1spec)}
>player p2 ${JSON.stringify(p2spec)}`);

        // Emit battle start event
        this.eventEmitter.emit("battleStart", this.getState());
    }

    /**
     * Process a player's move decision
     * @param player - The player ID
     * @param decision - The player's decision
     */
    processPlayerDecision(player: "p1" | "p2", decision: PlayerDecision): void {
        if (decision.type === "move") {
            const moveIndex = decision.moveIndex;
            this.battleState[player].selectedMove = moveIndex;

            // Make the move
            if (player === "p1") {
                void this.p1Stream.write(`move ${moveIndex}`);
            } else {
                void this.p2Stream.write(`move ${moveIndex}`);
            }

            // Emit move event
            this.eventEmitter.emit("playerMove", {
                player,
                moveIndex
            });
        }

        // Check if both players have made a move this turn
        if (this.battleState.p1.selectedMove !== null &&
            this.battleState.p2.selectedMove !== null) {
            // Reset selected moves for next turn
            this.battleState.p1.selectedMove = null;
            this.battleState.p2.selectedMove = null;

            // Emit turn complete event
            this.eventEmitter.emit("turnComplete", this.battleState.turn);
        }
    }

    /**
     * Get data for a move
     * @param moveId - The move ID
     * @returns The move data
     */
    getMoveData(moveId: string) {
        return this.dex.moves.get(moveId);
    }

    /**
     * Get data for an item
     * @param itemId - The item ID
     * @returns The item data
     */
    getItem(itemId: string) {
        return this.dex.items.get(itemId);
    }

    /**
     * Get data for an ability
     * @param abilityId - The ability ID
     * @returns The ability data
     */
    getAbility(abilityId: string) {
        return this.dex.abilities.get(abilityId);
    }

    /**
     * Get the current battle state (immutable)
     * @returns A copy of the battle state
     */
    getState(): Readonly<BattleState> {
        return { ...this.battleState };
    }

    /**
     * Subscribe to battle events with type safety
     * @param event - The event name 
     * @param listener - The event listener function
     * @returns A function to unsubscribe
     */
    on<K extends keyof BattleEventMap>(
        event: K,
        listener: (data: BattleEventMap[K]) => void
    ): () => void {
        return this.eventEmitter.on(event, listener);
    }
} 

---
app/services/battle-event-emitter.ts
---
import type { BattleState, PlayerRequest } from "./battle-types";

/**
 * Type-safe event map for battle events
 */
export interface BattleEventMap {
    stateUpdate: Readonly<BattleState>;
    battleStart: Readonly<BattleState>;
    battleEnd: { winner: string; state: Readonly<BattleState> };
    turnStart: number;
    turnComplete: number;
    playerMove: { player: "p1" | "p2"; moveIndex: number };
    playerRequest: { player: "p1" | "p2"; request: PlayerRequest };
}

/**
 * Simple event emitter for battle events
 */
export class BattleEventEmitter {
    private events: Record<string, Array<(data: unknown) => void>> = {};

    /**
     * Register an event listener with type safety
     * @param event - The event name
     * @param listener - The event listener function
     * @returns A function to unsubscribe
     */
    on<K extends keyof BattleEventMap>(
        event: K,
        listener: (data: BattleEventMap[K]) => void
    ): () => void {
        // Type assertion here is necessary because we maintain type safety through the generic
        return this.addListener(event, listener as (data: unknown) => void);
    }

    /**
     * Internal method to add a listener
     */
    private addListener(event: string, listener: (data: unknown) => void): () => void {
        if (!this.events[event]) {
            this.events[event] = [];
        }
        this.events[event].push(listener);

        // Return unsubscribe function
        return () => {
            this.events[event] = this.events[event].filter(l => l !== listener);
        };
    }

    /**
     * Emit an event with type safety
     * @param event - The event name
     * @param data - The event data
     */
    emit<K extends keyof BattleEventMap>(event: K, data?: BattleEventMap[K]): void {
        if (!this.events[event]) return;

        for (const listener of this.events[event]) {
            try {
                listener(data as unknown);
            } catch (error) {
                console.error(`Error in event listener for ${event}:`, error);
            }
        }
    }

    /**
     * Remove all listeners for an event
     * @param event - The event name (optional, if not provided, removes all listeners)
     */
    removeAllListeners(event?: string): void {
        if (event) {
            this.events[event] = [];
        } else {
            this.events = {};
        }
    }
} 

---
app/services/battle-manager.ts
---
import { BattleEngine } from "./battle-engine";
import type { BattleOptions, BattleState, PlayerDecision } from "./battle-types";

/**
 * Class for managing Pokemon battles
 */
export class BattleManager {
    private battles: Map<string, BattleEngine> = new Map();

    /**
     * Create a new battle
     * @param battleId - Unique identifier for the battle
     * @param options - Battle options
     * @returns The created battle engine
     */
    createBattle(battleId: string, options: BattleOptions): BattleEngine {
        // Check if battle with this ID already exists
        if (this.battles.has(battleId)) {
            throw new Error(`Battle with ID ${battleId} already exists`);
        }

        // Create new battle engine
        const battleEngine = new BattleEngine(options);
        
        // Store in battles map
        this.battles.set(battleId, battleEngine);
        
        // Set up cleanup when battle ends
        battleEngine.on("battleEnd", () => {
            // Keep the battle for a while before removing
            setTimeout(() => {
                this.removeBattle(battleId);
            }, 60000); // 1 minute
        });
        
        return battleEngine;
    }

    /**
     * Get a battle by ID
     * @param battleId - The battle ID
     * @returns The battle engine or undefined if not found
     */
    getBattle(battleId: string): BattleEngine | undefined {
        return this.battles.get(battleId);
    }

    /**
     * Remove a battle
     * @param battleId - The battle ID
     * @returns True if battle was removed, false if not found
     */
    removeBattle(battleId: string): boolean {
        return this.battles.delete(battleId);
    }

    /**
     * Get all active battle IDs
     * @returns Array of battle IDs
     */
    getActiveBattleIds(): string[] {
        return Array.from(this.battles.keys());
    }

    /**
     * Start a battle
     * @param battleId - The battle ID
     * @param p1Team - Player 1's team
     * @param p2Team - Player 2's team
     */
    startBattle(battleId: string, p1Team?: string, p2Team?: string): void {
        const battle = this.getBattle(battleId);
        if (!battle) {
            throw new Error(`Battle with ID ${battleId} not found`);
        }
        
        battle.startBattle(p1Team, p2Team);
    }

    /**
     * Make a move for a player
     * @param battleId - The battle ID
     * @param player - The player ("p1" or "p2")
     * @param decision - The player's decision
     */
    makePlayerMove(
        battleId: string, 
        player: "p1" | "p2", 
        decision: PlayerDecision
    ): void {
        const battle = this.getBattle(battleId);
        if (!battle) {
            throw new Error(`Battle with ID ${battleId} not found`);
        }
        
        battle.processPlayerDecision(player, decision);
    }

    /**
     * Get the current state of a battle
     * @param battleId - The battle ID
     * @returns The battle state
     */
    getBattleState(battleId: string): Readonly<BattleState> | undefined {
        const battle = this.getBattle(battleId);
        if (!battle) {
            return undefined;
        }
        
        return battle.getState();
    }
} 

---
app/services/battle-types.ts
---
import type { Pokemon } from "@pkmn/client";

/**
 * Interface for move data
 */
export interface MoveData {
    id: string;
    move: string;
    pp: number;
    maxpp: number;
    disabled?: boolean;
}

/**
 * Interface for battle options
 */
export interface BattleOptions {
    format: string;
    p1Name: string;
    p2Name: string;
    p1Team?: string;
    p2Team?: string;
    onBattleUpdate?: (state: BattleState) => void;
}

/**
 * Interface for player state in battle
 */
export interface PlayerState {
    name: string;
    active: Pokemon | null;
    team: Pokemon[];
    request: PlayerRequest | null;
    selectedMove: number | null;
}

/**
 * Interface for battle state
 */
export interface BattleState {
    turn: number;
    p1: PlayerState;
    p2: PlayerState;
    weather: string;
    status: string;
    logs: string[];
    isComplete: boolean;
    winner: string | null;
}

/**
 * Interface for player move decision
 */
export interface MoveDecision {
    type: "move";
    moveIndex: number;
}

/**
 * Interface for player switch decision
 */
export interface SwitchDecision {
    type: "switch";
    pokemonIndex: number;
}

/**
 * Interface for player request
 */
export interface PlayerRequest {
    active: {
        moves: MoveData[];
    }[];
    side: {
        id: string;
        name: string;
        pokemon: Pokemon[];
    };
}

/**
 * Union type for player decisions
 */
export type PlayerDecision = MoveDecision | SwitchDecision;

/**
 * Interface for battle turn result
 */
export interface TurnResult {
    turn: number;
    state: Readonly<BattleState>;
}

/**
 * Interface for battle end result
 */
export interface BattleEndResult {
    winner: string;
    state: Readonly<BattleState>;
}

/**
 * Interface for player move event
 */
export interface PlayerMoveEvent {
    player: "p1" | "p2";
    moveIndex: number;
}

/**
 * Interface for player request event
 */
export interface PlayerRequestEvent {
    player: "p1" | "p2";
    request: PlayerRequest;
} 

---
app/services/battle.service.ts
---
import { Battle, type Pokemon } from "@pkmn/client";
import { Generations } from "@pkmn/data";
import {
    type ArgName,
    type ArgType,
    type BattleArgsKWArgType,
    Protocol,
} from "@pkmn/protocol";
import { TeamGenerators } from "@pkmn/randoms";
import {
    BattleStreams,
    Teams as DTeams,
    Dex,
    type ModdedDex,
    PRNG,
} from "@pkmn/sim";
import type { ObjectReadWriteStream } from "@pkmn/streams";
import { LogFormatter } from "@pkmn/view";
import type { BattleRequest } from "./player";

/**
 * Interface for battle options
 */
interface BattleOptions {
    format: string;
    p1Name: string;
    p2Name: string;
    p1Team?: string;
    p2Team?: string;
    onBattleUpdate?: (state: BattleState) => void;
}

/**
 * Interface for battle state
 */
interface BattleState {
    turn: number;
    p1: {
        active: Pokemon | null;
        team: Pokemon[];
        request: BattleRequest | null;
        selectedMove: number | null;
    };
    p2: {
        active: Pokemon | null;
        team: Pokemon[];
        request: BattleRequest | null;
        selectedMove: number | null;
    };
    weather: string;
    status: string;
    logs: string[];
}

/**
 * Class representing a manual player in a Pokémon battle
 */
class ManualPlayer {
    stream: ObjectReadWriteStream<string>;
    log: string[] = [];
    debug: boolean;
    currentRequest: BattleRequest | null = null;
    playerName: string;
    onRequestReceived: (request: BattleRequest) => void;

    /**
     * Create a manual player
     * @param playerStream - The player's stream
     * @param debug - Whether to enable debug logging
     * @param playerName - The player's name
     * @param onRequestReceived - Callback for when a request is received
     */
    constructor(
        playerStream: ObjectReadWriteStream<string>,
        debug = false,
        playerName = "Unknown",
        onRequestReceived: (request: BattleRequest) => void = () => { },
    ) {
        this.stream = playerStream;
        this.debug = debug;
        this.playerName = playerName;
        this.onRequestReceived = onRequestReceived;

        void this.startListening();
    }

    /**
     * Start listening to the stream
     */
    async startListening(): Promise<void> {
        try {
            for await (const chunk of this.stream) {
                this.receive(chunk);
            }
        } catch (error) {
            console.error(`${this.playerName} stream error:`, error);
        }
    }

    /**
     * Receive a chunk of data from the stream
     * @param chunk - The data chunk
     */
    receive(chunk: string): void {
        if (this.debug) console.log(`${this.playerName} received:`, chunk);

        for (const line of chunk.split("\n")) {
            this.receiveLine(line);
        }
    }

    /**
     * Receive a line of data
     * @param line - The data line
     */
    receiveLine(line: string): void {
        if (this.debug) console.log(`${this.playerName} line:`, line);
        if (!line.startsWith("|")) return;

        const [cmd, rest] =
            line.slice(1).split("|", 1)[0] === ""
                ? ["", line.slice(1)]
                : [
                    line.slice(1).split("|", 1)[0],
                    line.slice(line.indexOf("|", 1) + 1),
                ];

        if (cmd === "request") {
            try {
                const request = JSON.parse(rest);
                this.receiveRequest(request);
            } catch (e) {
                console.error(`${this.playerName} error parsing request:`, e, rest);
            }
            return;
        }

        if (cmd === "error") {
            this.receiveError(new Error(rest));
            return;
        }

        this.log.push(line);
    }

    /**
     * Handle an error
     * @param error - The error
     */
    receiveError(error: Error): void {
        console.error(`${this.playerName} battle error:`, error);

        // If we made an unavailable choice we will receive a followup request to
        // allow us the opportunity to correct our decision.
        if (error.message.startsWith("[Unavailable choice]")) return;
    }

    /**
     * Handle a request
     * @param request - The request
     */
    receiveRequest(request: BattleRequest): void {
        this.currentRequest = request;
        if (this.debug)
            console.log(`${this.playerName} received request:`, request);
        this.onRequestReceived(request);
    }

    /**
     * Make a move
     * @param moveIndex - The move index (1-based)
     */
    makeMove(moveIndex: number): void {
        this.makeChoice(`move ${moveIndex}`);
    }

    /**
     * Make a choice
     * @param choice - The choice string
     */
    makeChoice(choice: string): void {
        console.log(`${this.playerName} making choice: ${choice}`);
        try {
            void this.stream.write(choice);
        } catch (error) {
            console.error(`${this.playerName} error making choice:`, error);
        }
    }
}

/**
 * Class for handling Pokémon battles
 */
export class BattleService {
    private battle: Battle;
    private streams: ReturnType<typeof BattleStreams.getPlayerStreams>;
    private p1: ManualPlayer;
    private p2: ManualPlayer;
    private formatter: LogFormatter;
    private prng: PRNG;
    private dex: ModdedDex;
    private gens: Generations;
    private format: string;
    private battleState: BattleState;
    private onBattleUpdate: (state: BattleState) => void;

    /**
     * Create a battle service
     * @param options - The battle options
     */
    constructor(options: BattleOptions) {
        this.format = options.format || "gen3randombattle";
        this.prng = new PRNG();
        this.dex = Dex.forFormat(this.format);
        // @ts-ignore
        this.gens = new Generations(Dex);
        this.onBattleUpdate = options.onBattleUpdate || (() => { });

        // Set up team generators
        DTeams.setGeneratorFactory(TeamGenerators);

        // Initialize battle state
        this.battleState = {
            turn: 0,
            p1: { active: null, team: [], request: null, selectedMove: null },
            p2: { active: null, team: [], request: null, selectedMove: null },
            weather: "none",
            status: "Initializing battle...",
            logs: [],
        };

        // Create battle streams
        this.streams = BattleStreams.getPlayerStreams(
            new BattleStreams.BattleStream(),
        );

        // Create battle instance
        this.battle = new Battle(this.gens);

        // Create formatter
        this.formatter = new LogFormatter("p1", this.battle);

        // Create players
        this.p1 = new ManualPlayer(
            this.streams.p1,
            true,
            options.p1Name || "Player 1",
            (request) => this.handlePlayerRequest("p1", request),
        );

        this.p2 = new ManualPlayer(
            this.streams.p2,
            true,
            options.p2Name || "Player 2",
            (request) => this.handlePlayerRequest("p2", request),
        );

        // Start listening to the omniscient stream
        this.startBattleStream();
    }

    /**
     * Start the battle stream
     */
    private async startBattleStream(): Promise<void> {
        try {
            for await (const chunk of this.streams.omniscient) {
                for (const line of chunk.split("\n")) {
                    const { args, kwArgs } = Protocol.parseBattleLine(line);
                    const html = this.formatter.formatHTML(args, kwArgs);
                    const key = Protocol.key(args);

                    // Pre-processing
                    this.preProcess(key, args, kwArgs);

                    // Update battle state
                    this.battle.add(args, kwArgs);

                    // Post-processing
                    this.postProcess(key, args, kwArgs);

                    if (html) {
                        this.battleState.logs.push(html);
                    }
                }

                // Update battle
                this.battle.update();

                // Notify listeners
                this.onBattleUpdate({ ...this.battleState });
            }
        } catch (error) {
            console.error("Battle stream error:", error);
        }
    }

    /**
     * Pre-process battle events
     * @param key - The event key
     * @param args - The event arguments
     * @param kwArgs - The event keyword arguments
     */
    private preProcess(
        key: ArgName | undefined,
        args: ArgType,
        kwArgs: BattleArgsKWArgType,
    ): void {
        if (key === "|faint|") {
            const pokemonId = args[1] as string;
            this.handleFaint(pokemonId);
        }
    }

    /**
     * Post-process battle events
     * @param key - The event key
     * @param args - The event arguments
     * @param kwArgs - The event keyword arguments
     */
    private postProcess(
        key: ArgName | undefined,
        args: ArgType,
        kwArgs: BattleArgsKWArgType,
    ): void {
        if (key === "|teampreview|") {
            this.battleState.p1.team = [...this.battle.p1.team];
            this.battleState.p2.team = [...this.battle.p2.team];
            this.battleState.status = "Team preview";
        } else if (key === "|turn|") {
            this.battleState.turn = Number(args[1]);
            this.battleState.status = `Current Turn: ${this.battleState.turn}`;

            // Update active Pokémon
            this.battleState.p1.active = this.battle.p1.active[0] || null;
            this.battleState.p2.active = this.battle.p2.active[0] || null;
        } else if (key === "|-weather|") {
            const weather = args[1] as string;
            this.battleState.weather = weather;

            // Update status message based on weather
            let weatherText = "";
            switch (weather) {
                case "RainDance":
                    weatherText = "It's raining!";
                    break;
                case "Sandstorm":
                    weatherText = "A sandstorm is raging!";
                    break;
                case "SunnyDay":
                    weatherText = "The sunlight is strong!";
                    break;
                case "Hail":
                    weatherText = "It's hailing!";
                    break;
                case "none":
                    weatherText = "The weather cleared up!";
                    break;
                default:
                    weatherText = `Weather: ${weather}`;
            }
            this.battleState.status = weatherText;
        }
    }

    /**
     * Handle a fainted Pokémon
     * @param pokemonId - The Pokémon ID
     */
    private handleFaint(pokemonId: string): void {
        console.log(`${pokemonId} has fainted!`);

        // Determine the winner
        const winner = pokemonId.startsWith("p1") ? "p2" : "p1";
        const winnerName =
            winner === "p1" ? this.p1.playerName : this.p2.playerName;

        // Update battle status
        this.battleState.status = `${winnerName} has won the battle!`;
    }

    /**
     * Handle a player request
     * @param player - The player ID
     * @param request - The request
     */
    private handlePlayerRequest(
        player: "p1" | "p2",
        request: BattleRequest,
    ): void {
        // Store the request in battle state
        this.battleState[player].request = request;

        // Update active Pokémon if available
        if (request.active && request.side && request.side.pokemon) {
            const activePokemon = this.battle[player].active[0];
            if (activePokemon) {
                this.battleState[player].active = activePokemon;
            }
        }

        // Notify listeners
        this.onBattleUpdate({ ...this.battleState });
    }

    /**
     * Start the battle
     * @param p1Team - Optional team for player 1
     * @param p2Team - Optional team for player 2
     */
    startBattle(p1Team?: string, p2Team?: string): void {
        const spec = { formatid: this.format };
        const p1spec = {
            name: this.p1.playerName,
            team: p1Team ? DTeams.import(p1Team) : null,
        };
        const p2spec = {
            name: this.p2.playerName,
            team: p2Team ? DTeams.import(p2Team) : null,
        };

        // Start the battle
        void this.streams.omniscient.write(`>start ${JSON.stringify(spec)}
>player p1 ${JSON.stringify(p1spec)}
>player p2 ${JSON.stringify(p2spec)}`);
    }

    /**
     * Make a move for player 1
     * @param moveIndex - The move index (1-based)
     */
    makeP1Move(moveIndex: number): void {
        this.p1.makeMove(moveIndex);
    }

    /**
     * Make a move for player 2
     * @param moveIndex - The move index (1-based)
     */
    makeP2Move(moveIndex: number): void {
        this.p2.makeMove(moveIndex);
    }

    /**
     * Get the current battle state
     * @returns The battle state
     */
    getBattleState(): BattleState {
        return { ...this.battleState };
    }

    /**
     * Get move data for a Pokémon
     * @param moveId - The move ID
     * @returns The move data
     */
    getMoveData(moveId: string) {
        return this.dex.moves.get(moveId);
    }

    getItem(itemId: string) {
        return this.dex.items.get(itemId);
    }

    getAbility(abilityId: string) {
        return this.dex.abilities.get(abilityId);
    }
}


---
app/services/player.ts
---
import type { ObjectReadWriteStream } from "@pkmn/streams";
import type { PlayerRequest } from "./battle-types";
/**
 * Class representing a manual player in a Pokémon battle
 */
export class ManualPlayer {
    stream: ObjectReadWriteStream<string>;
    log: string[] = [];
    debug: boolean;
    playerName: string;
    onRequestReceived: (request: PlayerRequest) => void;

    /**
     * Create a manual player
     * @param playerStream - The player's stream
     * @param debug - Whether to enable debug logging
     * @param playerName - The player's name
     * @param onRequestReceived - Callback for when a request is received
     */
    constructor(
        playerStream: ObjectReadWriteStream<string>,
        debug = false,
        playerName = "Unknown",
        onRequestReceived: (request: PlayerRequest) => void = () => { },
    ) {
        this.stream = playerStream;
        this.debug = debug;
        this.playerName = playerName;
        this.onRequestReceived = onRequestReceived;

        void this.startListening();
    }

    /**
     * Start listening to the stream
     */
    async startListening(): Promise<void> {
        try {
            for await (const chunk of this.stream) {
                this.receive(chunk);
            }
        } catch (error) {
            console.error(`${this.playerName} stream error:`, error);
        }
    }

    /**
     * Receive a chunk of data from the stream
     * @param chunk - The data chunk
     */
    receive(chunk: string): void {
        if (this.debug) console.log(`${this.playerName} received:`, chunk);

        for (const line of chunk.split("\n")) {
            this.receiveLine(line);
        }
    }

    /**
     * Receive a line of data
     * @param line - The data line
     */
    receiveLine(line: string): void {
        if (this.debug) console.log(`${this.playerName} line:`, line);
        if (!line.startsWith("|")) return;

        const [cmd, rest] =
            line.slice(1).split("|", 1)[0] === ""
                ? ["", line.slice(1)]
                : [
                    line.slice(1).split("|", 1)[0],
                    line.slice(line.indexOf("|", 1) + 1),
                ];

        if (cmd === "request") {
            try {
                const request = JSON.parse(rest);
                this.receiveRequest(request);
            } catch (e) {
                console.error(`${this.playerName} error parsing request:`, e, rest);
            }
            return;
        }

        if (cmd === "error") {
            this.receiveError(new Error(rest));
            return;
        }

        this.log.push(line);
    }

    /**
     * Handle an error
     * @param error - The error
     */
    receiveError(error: Error): void {
        console.error(`${this.playerName} battle error:`, error);

        // If we made an unavailable choice we will receive a followup request to
        // allow us the opportunity to correct our decision.
        if (error.message.startsWith("[Unavailable choice]")) return;
    }

    /**
     * Handle a request
     * @param request - The request
     */
    receiveRequest(request: PlayerRequest): void {
        if (this.debug) console.log(`${this.playerName} received request:`, request);
        this.onRequestReceived(request);
    }

    /**
     * Make a move
     * @param moveIndex - The move index (1-based)
     */
    makeMove(moveIndex: number): void {
        this.makeChoice(`move ${moveIndex}`);
    }

    /**
     * Make a choice
     * @param choice - The choice string
     */
    makeChoice(choice: string): void {
        console.log(`${this.playerName} making choice: ${choice}`);
        try {
            void this.stream.write(choice);
        } catch (error) {
            console.error(`${this.playerName} error making choice:`, error);
        }
    }
}

---
app/store/battle-store.ts
---
import { create } from 'zustand';
import type { PokemonData } from '@/components/PokemonSelector';

interface BattleState {
  selectedPokemon: PokemonData | null;
  selectedMoves: string[];
  p1Team: string;
  opponentPokemon: PokemonData | null;
  opponentMoves: string[];
  p2Team: string;
  isLoading: boolean;
  setSelectedPokemon: (pokemon: PokemonData | null) => void;
  setSelectedMoves: (moves: string[]) => void;
  setP1Team: (team: string) => void;
  setOpponentPokemon: (pokemon: PokemonData | null) => void;
  setOpponentMoves: (moves: string[]) => void;
  setP2Team: (team: string) => void;
  setIsLoading: (loading: boolean) => void;
  reset: () => void;
}

export const useBattleStore = create<BattleState>((set) => ({
  selectedPokemon: null,
  selectedMoves: [],
  p1Team: '',
  opponentPokemon: null,
  opponentMoves: [],
  p2Team: '',
  isLoading: false,
  setSelectedPokemon: (pokemon) => set({ selectedPokemon: pokemon }),
  setSelectedMoves: (moves) => set({ selectedMoves: moves }),
  setP1Team: (team) => set({ p1Team: team }),
  setP2Team: (team) => set({ p2Team: team }),
  setOpponentPokemon: (pokemon) => set({ opponentPokemon: pokemon }),
  setOpponentMoves: (moves) => set({ opponentMoves: moves }),
  setIsLoading: (loading) => set({ isLoading: loading }),
  reset: () => set({
    selectedPokemon: null,
    selectedMoves: [],
    p1Team: '',
    opponentPokemon: null,
    opponentMoves: [],
    p2Team: '',
    isLoading: false
  }),
})); 

---
app/store/settings.ts
---
import { create } from "zustand";
import { persist } from "zustand/middleware";
import type { GenerationNum } from "@pkmn/types";

interface SettingsState {
    generation: GenerationNum;
    setGeneration: (generation: GenerationNum) => void;
}

export const useSettings = create<SettingsState>()(
    persist(
        (set) => ({
            generation: 3,
            setGeneration: (generation) => set({ generation }),
        }),
        {
            name: "pokemon-battle-settings",
        }
    )
); 

---
lib/constants.ts
---
import type { GraphicsGen } from "@pkmn/img";
import { PRNG } from "@pkmn/sim";
import type { GenerationNum, TypeName } from "@pkmn/types";

const SPRITES: { [gen in GenerationNum]: GraphicsGen[] } = {
    1: ['gen1rg', 'gen1rb', 'gen1'],
    2: ['gen2g', 'gen2s', 'gen2'],
    3: ['gen3rs', 'gen3frlg', 'gen3', 'gen3-2'],
    4: ['gen4dp', 'gen4dp-2', 'gen4'],
    5: ['gen5', 'gen5ani'],
    6: ['ani'],
    7: ['ani'],
    8: ['ani'],
    9: ['ani'],
};

const prng = new PRNG();
export const getFormat = (generation: GenerationNum) => `gen${generation}randombattle`;
export const getGraphics = (generation: GenerationNum) => prng.sample(SPRITES[generation]);

// Type color mapping
export const TYPE_COLORS: Partial<Record<TypeName, string>> = {
    Normal: "bg-gray-400",
    Fire: "bg-red-500",
    Water: "bg-blue-500",
    Electric: "bg-yellow-400",
    Grass: "bg-green-500",
    Ice: "bg-blue-200",
    Fighting: "bg-red-700",
    Poison: "bg-purple-500",
    Ground: "bg-yellow-600",
    Flying: "bg-indigo-400",
    Psychic: "bg-pink-500",
    Bug: "bg-lime-500",
    Rock: "bg-yellow-800",
    Ghost: "bg-purple-700",
    Dragon: "bg-indigo-600",
    Dark: "bg-gray-800",
    Steel: "bg-gray-500",
    Fairy: "bg-pink-300",
};

---
lib/utils.ts
---
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}


export const getStatusClass = (status: string): string => {
  // Get status class for styling
  switch (status.toLowerCase()) {
    case "par":
      return "bg-yellow-400 text-yellow-900";
    case "psn":
    case "tox":
      return "bg-purple-600 text-white";
    case "brn":
      return "bg-orange-500 text-white";
    case "slp":
      return "bg-gray-400 text-gray-900";
    case "frz":
      return "bg-blue-300 text-blue-900";
    default:
      return "bg-gray-600 text-white";
  }
};

// Get status display name
export const getStatusName = (status: string): string => {
  switch (status.toLowerCase()) {
    case "par":
      return "Paralyzed";
    case "psn":
      return "Poisoned";
    case "tox":
      return "Badly Poisoned";
    case "brn":
      return "Burned";
    case "slp":
      return "Asleep";
    case "frz":
      return "Frozen";
    default:
      return status;
  }
};


---
